,Bug_No,Topics,Text
0,0,"5 0.31192881192881194, 6 0.12337662337662335, 2 0.12000962000962004, 4 0.11495911495911498, 1 0.1115921115921116, 0 0.10990860990860993, 3 0.10822510822510824","ï»¿adding 2 patches. one includes a comprehensive review of the builder package, both style and syntax along with just syntax fixes for the other packages.the other fixes minor typos in the builder test package. "
1,1,"3 0.23939986953685585, 5 0.1663405088062622, 2 0.1404653185475103, 4 0.1313328984561861, 6 0.1191563383344205, 0 0.10545770819743422, 1 0.09784735812133075","hi,the javadoc examples for the stringutils.splitbywholeseparator(...) methods are not correct.- the examples of splitbywholeseperator(string,string) are illustrating the usage of the stringutils.split(string,string) method.- the 6th example of splitbywholeseperator(string,string,int) is not correct and should be removed.regards,maarten "
2,2,"4 0.2613510520487265, 0 0.18770764119601327, 3 0.15153193060169803, 5 0.11664820967146547, 2 0.09985234403839052, 1 0.09856035437430784, 6 0.08434846806939832","the padding array in class stringutils is one entry too short.as declared, it overflows on \uffff.to test, run: stringutils.leftpad(""abcd"", 10, \ufffe) // no exception stringutils.leftpad(""abcd"", 10, \uffff) // arrayindexoutofboundsexceptioncurrent code: private static final string[] padding = new string[character.max_value];suggested fix: private static final string[] padding = new string[character.max_value + 1]; "
3,3,"5 0.22117794486215542, 4 0.17293233082706766, 2 0.1539264828738513, 0 0.15246449456975772, 3 0.10714285714285712, 6 0.09837092731829576, 1 0.09398496240601506","i just discovered that the method tostringbuilder.reflectiontostring() does not work in a class hierarchy.for example:class a defines inst var a.class b extends a defines inst var b.new a().tostring returns ""a=...""new b().tostring returns ""b=...""when i expected new b().tostring to return ""a=...,b=...""can i use reflectiontostring() to accomplish this?thank you for considering this request.gary "
4,4,"2 0.3859943977591037, 0 0.11932773109243695, 4 0.11671335200746963, 3 0.11017740429505132, 6 0.09579831932773106, 1 0.08795518207282915, 5 0.08403361344537817","stringutils.split ignores empty items (eg. delimiter at the beginning of the string, 2 delimiters directly after another)eg.string[] l = stringutils.split(""x,de,germany"", "","");results in l[0] = ""x""l[1] = ""de""l[2] = ""germany""string[] l = stringutils.split("",de,germany"", "","");results inl[0] = ""de""l[1] = ""germany""expected : l[0] = """" (or null ?)l[1] = ""de""l[2] = ""germany""the current behaviour makes it impossible to detect the ""column"" (eg. for parsing .csv files). "
5,5,"3 0.33454849244322915, 4 0.2260955418850156, 0 0.13784461152882205, 5 0.12987012987012986, 2 0.07723855092276143, 1 0.04799878484089008, 6 0.04640388850915165","append two arrays of any object type to an equalsbuilder using equalsbuilder.append(object[], object[]) -- well call the first lhs and the second rhs. if, for any i, lhs[i] is not null, rhs[i] is not null, and rhs[i] is not of the same type as, or a subtype of, lhs[i], then the equalsbuilder will return false.however, this behavior is incorrect. while rare, it is perfectly valid in java to define an equals() method on a class a that will return true when passed in an object of some class b, where b is not the same as a nor a subtype of a. (a conceptual example is comparing a rgbcolor to a cmykcolor, where rgbcolor is not a subclass of cmykcolor, nor vice-versa. in this example, the equalsbuilder will return false, whether the equals() method is defined on rgbcolor to explicitly check cmykcolors, or even if you define a base-class color.equals() method that does an abstract comparison.)to reproduce:public static class a { private int a; public a(int a) { this.a = a; } public boolean equals(object o) { if (o == this) return true; if (o instanceof a) return this.a = ((a) o).geta(); if (o instanceof b) return this.a = ((b) o).getb(); return false; } public int geta() { return this.a; }}public static class b { private int b; public b(int b) { this.b = b; } public boolean equals(object o) { if (o == this) return true; if (o instanceof a) return this.b = ((a) o).geta(); if (o instanceof b) return this.b = ((b) o).getb(); return false; } public int getb() { return this.b; }}object[] x = new object[] { new a(1) };object[] y = new object[] { new b(1) };system.err.println(""x[0].equals(y[0])? "" + x[0].equals(y[0]));system.err.println(""does equalsbuilder think the arrays are equal? "" + (new equalsbuilder().append(x, y).isequals()));this program will output:truefalsethe attached patch adds to an existing unit-test case some code that proves the existence of this bug, and also fixes it. (it also fixes com-1842.) "
6,6,"1 0.2154566744730679, 2 0.1498829039812646, 4 0.1480614103564923, 5 0.1334894613583138, 3 0.11891751236013536, 0 0.11709601873536302, 6 0.11709601873536302","the following example from the javadoc is incorrect.stringutils.replace(""aba"", ""a"", """") = ""aba""it should be:stringutils.replace(""aba"", ""a"", """") = ""b"" "
7,7,"1 0.621808143547274, 4 0.0831608005521049, 3 0.07349896480331262, 5 0.06625258799171843, 0 0.05175983436853004, 2 0.05175983436853004, 6 0.05175983436853004","my program manages to generate this exceptionjavac psistatus.javapsistatus.java:59: cannot access org.apache.commons.lang.exception.nestableexceptionfile org/apache/commons/lang/exception/nestableexception.class not found connection con = torque.getconnection(""mypsi"");heres a snippet of source:package org.apache.jetspeed.portal.portlets;import org.apache.jetspeed.portal.portlets.abstractinstanceportlet;import org.apache.turbine.util.rundata;import org.apache.turbine.om.security.*;import org.apache.ecs.concreteelement;import org.apache.ecs.stringelement;import org.apache.torque.*;import javax.servlet.*;import java.sql.*;import javax.sql.*;import java.text.*;import java.util.*;public class myclass extends abstractinstanceportlet{ public concreteelement getcontent (rundata rundata) { connection con = torque.getconnection(""mypsi""); }} "
8,8,"1 0.17826617826617824, 4 0.1714285714285714, 5 0.15604395604395602, 6 0.14065934065934063, 2 0.12527472527472525, 0 0.11843711843711846, 3 0.1098901098901099",classutils.primitivetowrapper returns null when the specified class isvoid.type. because void.type is primitive but not present intoprimitivewrappermap. should return void.type instead. 
9,9,"6 0.21398046398046403, 3 0.20222832722832726, 2 0.1733821733821734, 4 0.1253052503052503, 5 0.1018009768009768, 0 0.09539072039072038, 1 0.0879120879120879","the following is directly from the javadoc page. please see inline notes.*** begin quote ***to use this class write code as follows: public class person { string name; int age; boolean issmoker; ... public string tostring() { return new tostringbuilder(this). append(name, ""name""). //!! should be - append(""name"", name). append(age, ""age""). //!! should be - append(""age"", age). append(smoker, ""smoker""). //!! should be - append(""smoker"", smoker). tostring(); } }*** end quote ***in short, the order of arguments to the append method in the example have been reversed.thank you. "
10,10,"6 0.24607203287406332, 2 0.2077189589879945, 4 0.1648537587623882, 3 0.11747643219724434, 0 0.11183627427282247, 5 0.09153170574490369, 1 0.06051083716058332","tostringbuilder.reflectiontostring() enters an infinite loop when used with the following example://///////////////////////////public class outer { inner inner = new inner(); class inner { public string tostring() { return tostringbuilder.reflectiontostring(this); } } public string tostring() { return tostringbuilder.reflectiontostring(this); } public static void main(string[] args) { outer outer = new outer(); system.out.println(outer); }}/////////////////////////////the reason is that the two classes refer to each other via the explicit field inner and the implicit field outer.this. the bug can be resolved by skipping the implicit fields. is there any good reason for printing those anyway?i am not sure what is the best way to detect if a field is an implicit field. but i patched the code myself in a way that seemed to work://///////////////////////////public static string reflectiontostring(object object, tostringstyle style, boolean outputtransients) { if (object == null) { throw new illegalargumentexception(""the object must not be null""); } if (style == null) { style = getdefaultstyle(); } field[] fields = object.getclass().getdeclaredfields(); field.setaccessible(fields, true); tostringbuilder builder = new tostringbuilder(object, style); for (int i = 0; i < fields.length; ++i) { field f = fields[i]; if (!f.getname().startswith(""this$"")) { if (outputtransients || !modifier.istransient(f.getmodifiers())) { if (!modifier.isstatic(f.getmodifiers())) { try { builder.append(f.getname(), f.get(object)); } catch (illegalaccessexception ex) { //this cant happen. would get a security exception instead //throw a runtime exception in case the impossible happens. throw new internalerror(""unexpected illegalaccessexception""); } } } } } return builder.tostring();}/////////////////////////////notice the extra if statement that tests for field names starting with ""this$"". i dont know if this is guaranteed to work always, though. "
11,11,"0 0.17972350230414744, 3 0.17255504352278545, 4 0.1474654377880184, 2 0.14567332309267791, 6 0.12416794674859194, 1 0.11520737327188943, 5 0.11520737327188943","low characters such as #18 are not escaped, and therefore are mixed together with other characteres as if there were normal characteres such as \a\, \1\ etc.possibly solved in other versions? "
12,12,"0 0.377005123036869, 2 0.2076929537246998, 1 0.09893340052070211, 6 0.09893340052070211, 3 0.09599395313681028, 4 0.06718736877467037, 5 0.054253800285546314","im assuming that the goal of the truncate() method inorg.apache.commons.lang.time.dateutils is to be a shorthand for the otherwisecumbersome java.util.calendar operations of setting all lower fields to 0.in other words, the following 2 methods are (by me) expected to yield the same: private date commonstruncate(date date) { return dateutils.truncate(date, calendar.date); } private date truncate(date date) { calendar c = calendar.getinstance(); c.settime(date); c.set(calendar.hour_of_day, 0); c.set(calendar.minute, 0); c.set(calendar.second, 0); c.set(calendar.millisecond, 0); return c.gettime(); }this is generally the case, except for the very pathological case of theultimate biggest date java allows you to make: date endoftime = new date(long.max_value); // fyi: sun aug 17 07:12:55 cet 292278994 -- 807 milliscommons-result: sun aug 17 02:00:00 cest 292278994 // commonstruncate(endoftime)handmade-result: sun aug 17 00:00:00 cest 292278994 // truncate(endoftime)(mind the 2h difference)another odd observation concerning this special date is that the commons-resultwill match the other one if we allow the commons truncate to operate on theresult again:commons-double-truncate-result: sun aug 17 00:00:00 cest 292278994 // truncate(truncate(endoftime))(which is somewhat another surprise: one would expect truncation not to change adate that was already truncated)my (totally wild) guess is that this is related to timezone and dst issuesfact being that similar effects are seen on all dates pointing to a moment inthe last 2hours of the date spectrum.i understand that this is a very hypothetical issue, nevertheless.kind regards,-marc= "
13,13,"0 0.20935960591133002, 2 0.17296113847837982, 1 0.12506841817186645, 3 0.12315270935960593, 4 0.12315270935960593, 5 0.12315270935960593, 6 0.12315270935960593","add systemutils.awt_toolkit, which is useful to detect whether or not the jre isrunning on a headless platform. "
14,14,"0 0.23395445134575574, 3 0.17598343685300208, 4 0.14699792960662525, 2 0.11801242236024843, 5 0.11801242236024843, 1 0.10351966873706007, 6 0.10351966873706007","there\s an error in the javadoc for the stringutils.chomp(string, string)method. one of the examples says:stringutils.chomp(""foo "", ""foo"") = ""foo""this should be:stringutils.chomp(""foo "", ""foo"") = ""foo "" "
15,15,"3 0.2530588624338625, 2 0.1789847883597884, 0 0.1575727513227513, 4 0.14773478835978834, 6 0.11127645502645503, 5 0.08928571428571429, 1 0.0620866402116402","equals considers self equal to any object that has an accessible public getname() method which returns a string that is the same than the internal name iname. so if you compare two objects of subclasses of enum that are not related otherwise, but incidentally have the same name iname the equals method returns true. but even worse, its also possible to compare a subclass of enum to an object of a totally unrelated class and to consider the objects equal if the totally unrelated class provides a getname method that returns a string equal to iname. if the getname method of the other object isnt accessible, an illegalaccessexception is thrown and caught in the equals method and false is returned which in this case seems to be correct.the root of the problem is the use of reflection without checking first whether the names of the classes (via other.getclass().getname().equals(this.getclass().getname())) are the same (not the classes themselves, this is tested by the equals method) before invoking the getname method on the other object via reflection. if the names of the classes arent equal, false can be returned immediately instead of using reflection. only if the classnames are equal reflection should be used to determine equality.note: the old implementation of enums.equals in the commons-lang 2.0 distribution seems to work ok in the first case with both objects being subclasses of enum. in the second case of the totally unrelated class, a classcastexception is thrown, but according to joshua bloch (effective java) and the sdk-api-documentation for object.equals this violates the contract for equals because equals is supposed to deliver true or false for any two non null references. "
16,16,"0 0.20264874866101865, 4 0.19037881001071186, 1 0.15561398383484273, 6 0.13857240237608337, 3 0.11198753530041874, 2 0.10585256597526536, 5 0.09494595384165937","this stems from a discussion on commons-user.the basic idea is that tostringstyle could be customized to include an optionaljava.text dataformat object. if the attched patch were in (mod some formattingand unit tests which i can do), user could write code like this:import java.lang.reflect.field;import java.text.simpledateformat;import java.util.date;import org.apache.commons.lang.builder.reflectiontostringbuilder;import org.apache.commons.lang.builder.tostringstyle;public class testrtsb { static class mytostringstyle extends tostringstyle { mytostringstyle() { this.setdateformat(new simpledateformat(""yyyy-mm-dd"")); } } public static void main(string[] arguments) { system.out.println(new testrtsb()); } private int foo = 22; private date mydate = new date(); public string tostring() { return new reflectiontostringbuilder(this, newmytostringstyle()).tostring(); }// use tostringstyle.setdateformat instead of://// public string tostring0() {// return (new reflectiontostringbuilder(this) {// protected object getvalue(field field) throwsillegalargumentexception, illegalaccessexception {// object value = super.getvalue(field);// if (""mydate"".equals(field.getname())) {// return new simpledateformat(""yyyy-mm-dd"").format(value);// } else {// return value;// }// }// }).tostring();// }}any thoughts? "
17,17,"0 0.2500543596434008, 4 0.16481843879104155, 3 0.13894324853228962, 2 0.12524461839530332, 6 0.12524461839530332, 1 0.09784735812133076, 5 0.09784735812133076","the first statement in validate.nonullemelents(object[], string) is validate.notnull(array). this should be validate.notnull(array, message). because of this, the message is not used when the array is null itself. this also applies to validate.nonullemelents(collection, string) "
18,18,"0 0.16099773242630386, 2 0.15570672713529854, 3 0.14512471655328796, 4 0.14512471655328796, 6 0.14512471655328796, 1 0.1345427059712774, 5 0.11337868480725626",according to the javadoc the various methods in the fraction class such as add()throw an illegalargumentexception when null is passed to them. this is veryunusual. they should throw a nullpointerexception instead 
19,19,"4 0.16931216931216925, 0 0.15079365079365076, 6 0.14256319811875368, 5 0.1405055849500294, 1 0.1322751322751323, 2 0.1322751322751323, 3 0.1322751322751323",the stringutils.chomp function doesn\t work.thanks 
20,20,"4 0.28583829365079366, 2 0.1764632936507936, 6 0.15042162698412695, 0 0.14868551587301584, 3 0.11743551587301584, 1 0.06448412698412696, 5 0.056671626984126984","the nestabledelegate dumps the stacktrace bottomup instead of topdown as is the custom in the jdk (especially in jdk 1.4s own chained exceptions).thus when using nestableexception you will always see the first low-level exception (e.g. an null exception) and youll have to go all the way to the bottom to see the highlevel exception (e.g. an hibernatequeryexception: error while parsing query at s.count())this is not very friendly to users because hopefully the highlevel exception will be the best explanation in 9 out of 10 causes, it is only when debugging or in misbehaved exception handling one like to see the root causes - and then one can go down and read the bottom of the stack trace.thus, i would suggest that you make it possible to have nestabledelegate print the stacktrace in reverce so the highlevel exception get printed first and then the lower-levels.and optimal one could set an nestabledelegate.printstacktracetopdown=true as an system property so one could choose which strategy should be activated in the system. am i making any sense ? :) "
21,21,"0 0.19585253456221194, 6 0.16538658474142343, 1 0.1474654377880184, 2 0.13133640552995388, 3 0.1295442908346134, 4 0.11520737327188942, 5 0.11520737327188942",default size of enum\s hashmap needs improvement.http://marc.theaimsgroup.com/?l=jakarta-commons-dev&m=104316379302781&w=2 
22,22,"3 0.2096474953617811, 1 0.1966604823747681, 0 0.17068645640074212, 4 0.11873840445269015, 2 0.10575139146567716, 6 0.10575139146567716, 5 0.09276437847866421","there is a small typo in the documentation at the url: http://jakarta.apache.org/commons/lang/api/org/apache/commons/lang/systemutils.htmlthe description for the static boolean is_java_1_5 is ""true iff this is javaversion 1.3."". i presume the version number really should be ""1.5"" rather than""1.3"" "
23,23,"2 0.23346560846560846, 3 0.15630511463844793, 0 0.15476190476190474, 4 0.13007054673721338, 6 0.12389770723104053, 1 0.10074955908289243, 5 0.10074955908289243","try to truncate 2004-10-31 01:00:00 mdt by hour and youll actually get 2004-10-31 01:00:00 mst, which is one hour after the input hour. // truncate 2004-10-31 01:00:00 mdt date oct31_01mdt = new date(1099206000000l); date result = dateutils.truncate(oct31_01mdt, calendar.hour_of_day); assertequals(oct31_01mdt, result); "
24,24,"4 0.24595893403232852, 0 0.16950633464394932, 3 0.16644823066841416, 2 0.15625455074996358, 6 0.11140235910878112, 1 0.07572447939420414, 5 0.07470511140235908","add the following to equalsbuildertest: public void testsubclassing() { testobject to2 = new testobject(5); testobject to1ter = new testsubobject(4, 10); testobject to1bis = new testsubobject(4, 10); testobject to1 = new testobject(4); testreflectionequalsequivalencerelationship(to1, to1bis, to1ter, to2,new testobject(), false); }as you can see, the whole concept behind appendsuperand such produces equals methods which are not symmetricand thus do not fulfill the equals contract.the two general solutions im aware of are: (1) make the equalsmethod final, so that subclasses are required to alluse the same equals method as each other and the superclass,or (2) use foo.getclass() == bar.getclass() insteadof instanceof, so that an instance of the superclass isnever equals to an instance of a subclass.in particular situations there might be specific solutions (look atthe way equals is defined for list and set for example). "
25,25,"3 0.19235942964756522, 6 0.1669357008340059, 2 0.15469464622006993, 4 0.15375302663438253, 0 0.130212536992198, 5 0.10384718859295128, 1 0.09819747107882698","i propose the following new interface characterencodingnames. ive stored aproposal in cvs to ""record"" it. even if we nuke it, it will be in the ""attic"".in short:/** * character encoding names required of every implementation of the java platform. * * according to the java documentation <a *href=""http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc"">jrecharacter encoding names</a>: * <p> * <cite>every implementation of the java platform is required to support thefollowing character encodings. consult the * release documentation for your implementation to see if any other encodingsare supported. </cite> * </p> * * @see <ahref=""http://java.sun.com/j2se/1.3/docs/api/java/lang/package-summary.html#charenc"">jrecharacter encoding * names </a> * @author apache software foundation * @since 2.1 */ "
26,26,"2 0.23136507936507933, 3 0.20558730158730157, 4 0.13625396825396824, 0 0.13003174603174603, 6 0.106031746031746, 1 0.09714285714285711, 5 0.09358730158730157","comparetobuilder does not seem to handle nulls well at all.in the methods:public comparetobuilder append(object lhs, object rhs)public comparetobuilder append(object[] lhs, object[] rhs)if either the lhs or rhs parameters are null, the code is set up to throw a nullpointerexception instead of evaulating on the basis of null. this requires that all object be vetted before they be placed in a sorting collection, not using the comparetobuilder class, modifying the source code, or subclassing comparetobuilder. we worked around this by subclassing comparetobuilder and overriding the methods in question.the following lines of code (in both methods) are the cause of the exception: if (comparison != 0) { return this; } if (lhs == rhs) { return this; } if (lhs == null || rhs == null) { throw new nullpointerexception(); }the if statement should be replaced with (?) : if (lhs == null && rhs != null) { comparison = -1; return this; } if (lhs != null && rhs == null) { comparison = 1; return this; } "
27,27,"3 0.1991341991341991, 0 0.18398268398268394, 4 0.14357864357864356, 6 0.13684463684463682, 1 0.12000962000962001, 2 0.10822510822510824, 5 0.10822510822510824","summary saids it all :)it means that server side exceptions cannot be transfered/serialized to clients, which is a must have to inform users on errors and be able to do a decent bughunt :) "
28,28,"0 0.20445392087183129, 2 0.1812366737739872, 3 0.16465292584695568, 6 0.12153518123667374, 5 0.1149016820658612, 1 0.10660980810234542, 4 0.10660980810234542","when dateutils.parsecvs parses a time in ""h:mm z"" format, the resulting date is1/1/1970. is this appropriate, or would it be more appropriate for the resultingdate to be the current system date?i don\t know what the cvs behavior is. "
29,29,"3 0.2896517780238711, 4 0.14322628276116647, 2 0.12772240679217423, 6 0.12255444813584347, 1 0.11307985726590376, 0 0.10705057216685121, 5 0.0967146548541897","hashcodebuilder class failed to generate unique hashcode for objects.here are codes to reproduce the problem:import org.apache.commons.lang.builder.hashcodebuilder;public class person{ public int id; public string name; public person(int id, string name) { this.id=id; this.name = name; } public int hashcode() { return new hashcodebuilder(17,37). append(id). append(name). tohashcode(); }}package com.ball.edi.prototype;public class testhashcode{ static public void main(string args[]) { person p1=new person(214686, ""03065""); person p2=new person(214691, ""03006""); system.out.println(""the hashcode for p1 is "" + p1.hashcode()); system.out.println(""the hashcode for p2 is "" + p2.hashcode()); }}when you ran testhashcode class, you will get the hashcode for p1 is 53862859the hashcode for p2 is 53862859i found this problem when i am using ojb.thanks. "
30,30,"2 0.16326530612244894, 6 0.155328798185941, 1 0.14937641723356007, 4 0.1473922902494331, 0 0.12953514739229027, 3 0.1275510204081633, 5 0.1275510204081633",added class hierachy support to hashcodebuilder.reflectionhashcode() with the following patches. 
31,31,"1 0.19827664399092973, 2 0.18938775510204084, 6 0.18811791383219958, 0 0.14621315192743764, 3 0.12208616780045352, 5 0.08081632653061223, 4 0.07510204081632652","the time unit tests fail when run on a sunday:test.time: [echo] running time package tests ... [java] ...f.f................ [java] time: 4.394 [java] there were 2 failures: [java] 1)testparse(org.apache.commons.lang.time.calendarutilstest)junit.framework.assertionfailederror:parse last sunday expected sun apr 27 06:39:17 mst 2003 but got sun apr 2006:39:17 mst 2003 [java] atorg.apache.commons.lang.time.calendarutilstest.assertequals(calendarutilstest.java:373) [java] atorg.apache.commons.lang.time.calendarutilstest.testparse(calendarutilstest.java:243) [java] at sun.reflect.nativemethodaccessorimpl.invoke0(native method) [java] atsun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:39) [java] atsun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:25) [java] 2)testweekiterator(org.apache.commons.lang.time.calendarutilstest)junit.framework.assertionfailederror: expected mon apr 28 00:00:00 mst 2003 but got mon apr 21 00:00:00 mst 2003 [java] atorg.apache.commons.lang.time.calendarutilstest.assertequals(calendarutilstest.java:373) [java] atorg.apache.commons.lang.time.calendarutilstest.assertweekiterator(calendarutilstest.java:346) [java] atorg.apache.commons.lang.time.calendarutilstest.assertweekiterator(calendarutilstest.java:324) [java] atorg.apache.commons.lang.time.calendarutilstest.testweekiterator(calendarutilstest.java:284) [java] at sun.reflect.nativemethodaccessorimpl.invoke0(native method) [java] atsun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:39) [java] atsun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:25)looks to me like the unit test code is checking the value of calendar.date, whenit should be looking at calendar.day_of_week (at line 237 and below) to decidewhether to make adjustments for today==sunday.when i fix this, testparse succeeds but testweekiterator hangs at the statementit = calendarutils.getcalendariterator(now, calendarutils.range_week_relative); "
32,32,"0 0.22085385878489328, 5 0.1461412151067323, 6 0.1403940886699507, 1 0.12315270935960594, 2 0.12315270935960594, 3 0.12315270935960594, 4 0.12315270935960594","fastdatefromat.getinstance(""dd.mm.yyyy"").format(date) returns ""01.01.01000"",when date is 1 januar 1000 (01.01.1000) "
33,33,"0 0.25452716297786726, 2 0.21305611446456518, 3 0.16454281243013638, 1 0.11994187346300023, 4 0.11915940084954169, 5 0.07142857142857142, 6 0.05734406438631789"," hello,in org.apache.commons.lang.stringutils, we can find stringutils.equals(?,?). org.apache.commons.lang.time.dateutils should have the same. like this : /** * <p>compares two dates, returning <code>true</code> if they are equal.</p> * * <p><code>null</code>s are handled without exceptions. two <code>null</code> * references are considered to be equal.</p> * * <pre> * dateutils.equals(null, null) = true * dateutils.equals(null, ""abc"") = false * dateutils.equals(""abc"", null) = false * dateutils.equals(""abc"", ""abc"") = true * dateutils.equals(""abc"", ""abc"") = false * </pre> * * @see java.util.date#equals(object) * @param dt1 the first date, may be null * @param dt2 the second date, may be null * @return <code>true</code> if the dates are equal or both <code>null</code> */ public static boolean equals(date dt1, date dt2) { return (dt1 == null ? dt2 == null : dt1.equals(dt2)); } "
34,34,"0 0.1718596903782089, 1 0.1595140113658632, 2 0.15814226925338035, 4 0.15539878502841464, 6 0.12522045855379188, 3 0.11699000587889476, 5 0.1128747795414462","classes that are located in org.apache.commons.lang.enum package cant be used with 1.5 jdk (aka the 5.0) because the ""enum"" is a reserved keyword. compiler error looks like this: ""as of release 1.5, enum is a keyword, and may not be used as an identifier (try -source 1.4 or lower to use enum as an identifier)""there probably should be a separate jar for 1.5+ jdk "
35,35,"6 0.2518693427784337, 0 0.25095106913288734, 4 0.12055621146530239, 2 0.10310901219992129, 1 0.09851764397218943, 3 0.09208972845336481, 5 0.08290699199790108","the min() method of numberutils returns the wrong result if the first value of the array happens to be float.nan. the following code snippet shows the behaviour: float a[] = new float[] {(float) 1.2, float.nan, (float) 3.7, (float) 27.0, (float) 42.0, float.nan}; float b[] = new float[] {float.nan, (float) 1.2, float.nan, (float) 3.7, (float) 27.0, (float) 42.0, float.nan}; float min = numberutils.min(a); system.out.println(""min(a): "" + min); // output: 1.2 min = numberutils.min(b); system.out.println(""min(b): "" + min); // output: nanthis problem may exist for double-arrays as well. proposal: use float.compare(float, float) or numberutils.compare(float, float) to achieve a consistent result. "
36,36,"4 0.17972350230414746, 2 0.16180235535074244, 3 0.14746543778801843, 6 0.13312852022529442, 0 0.1313364055299539, 5 0.1313364055299539, 1 0.11520737327188944","stringutils.isnumeric.if we put empty string as parameter we got true.stringutils.isnumeric("""") return true. "
37,37,"2 0.23775017253278127, 1 0.1902461467678859, 3 0.14596273291925466, 6 0.14596273291925466, 4 0.09684840119622727, 0 0.09523809523809522, 5 0.08799171842650103","the hashcode() methods of the range classes look very suspicious to me. the value is lazily initialized, but the calculation is done _on the cached value. with some unlucky timing a caller may get an incomplete hash.an unlucky sequence of code could be something liket1: if (hashcode == 0) // truet1: hashcode = 17;t2: if (hashcode == 0) // now false because hashcode was already set to 17t2: return hashcode; // return 17t1: hashcode = 37 * hashcode...........where t1 and t2 are different threads accessing the method in parallel and t2 gets the wrong hash ""17"".affected classes areorg.apache.commons.lang.math.doublerangeorg.apache.commons.lang.math.floatrangeorg.apache.commons.lang.math.intrangeorg.apache.commons.lang.math.longrangeorg.apache.commons.lang.math.numberrangeorg.apache.commons.lang.math.rangepossible fix: calculate the hash on a temporary variable and finally assign it to the member "
38,38,"2 0.2434386295772435, 0 0.20273455917020278, 4 0.14002828854314003, 5 0.11692597831211693, 6 0.10922520823510923, 3 0.10152443815810153, 1 0.08612289800408612","arrayutils.add(t[] array, t element) can create an unexpected classcastexception.for example, the following code compiles without a warning:{code}string[] sa = arrayutils.add(stringarray, astring);{code}and works fine, provided at least one of the parameters is non-null. however, if both parameters are null, the add() method returns an object[] array, hence the exception.if both parameters are null, its not possible to determine the correct array type to return, so it seems to me this should be disallowed.i think the method ought to be changed to throw illegalparameterexception when both parameters are null. "
39,39,"4 0.24394841269841278, 3 0.16200396825396826, 0 0.15714285714285714, 2 0.13769841269841274, 6 0.12172619047619049, 1 0.11825396825396826, 5 0.05922619047619047","see http://svn.apache.org/viewvc/commons/proper/lang/trunk/src/java/org/apache/commons/lang3/builder/hashcodebuilder.java?view=markupplease review the implementation for *reflectionappend* (lines 174 to 202)... specifically, see line 182:{code}list<string> excludedfieldlist = excludefields != null ? arrays.aslist(excludefields) : collections.<string>emptylist();{code}note that if you are in the habit of passing in a string array for excluding fields ({{string[] excludefields}}) -- which is a best practice when using hibernate (to skip primary keys ({{@id}}) and version fields ({{@version}}) that change upon persistence) -- _every time_ the _hashcode_ is calculated, an _arraylist_ is being created -- generating fodder for the garbage collector.i thought i might get around this by passing a {{collection<string>}} instead of a {{string[]}}, but ironically the implementation of the {{reflectionhashcode(object object, collection<string> excludefields)}} (see lines 475 to 477), for example, transforms the {{collection<string>}} into a {{string[]}} only to have it transformed internally into a temporary {{arraylist<string>}}.i would expect the implementation to use and read what is submitted, whether that is a {{string[]}} or a {{collection<string>}}. i dont think it needs to create another copy just to have a convenient {{contains}} method. efficiency is important, especially in the event of rehashing. "
40,40,"0 0.17875841436050863, 4 0.17235934513421428, 1 0.16654200947394665, 5 0.13803706473863542, 2 0.1368735976065819, 3 0.12989279481426078, 6 0.0775367738718524","the following program show a problem with a shortcoming of the java.util.properties class. the default properties are not substituted by the strsubstitutor.{code:title=strsubsttest.java|borderstyle=solid}import org.apache.commons.lang.text.strsubstitutor;public class strsubsttest{ public static void main(string[] args) { string org = ""${doesnotwork}""; system.setproperty(""doesnotwork"", ""it works!""); // create a new poperties object with the system.getproperties as default properties props = new properties(system.getproperties()); string subst = strsubstitutor.replace(org, props); // is ${doesnotwork} substituted? system.out.println(subst); }}{code} the following method could be added to the strsubstitutor class to fix this problem in an easy way:{code:borderstyle=solid} /** * replaces all the occurrences of variables in the given source object with their matching * values from the properties. * * @param source the source text containing the variables to substitute, null returns null * @param properties the properties with values, may be null * @return the result of the replace operation */ public static string replace(object source, properties valueproperties) { if (valueproperties == null) { return source; } map valuemap = new hashmap(); enumeration propnames = valueproperties.propertynames(); while (propnames.hasmoreelements()) { string propname = (string)propnames.nextelement(); string propvalue = valueproperties.getproperty(propname); valuemap.put(propname, propvalue); } return strsubstitutor.replace(source, valuemap); }{code} "
41,41,"3 0.20178571428571432, 4 0.1795634920634921, 2 0.16428571428571428, 5 0.12678571428571428, 0 0.1253968253968254, 6 0.11289682539682538, 1 0.0892857142857143","equalsbuilder causes stackoverflowexception when comparing objects with cyclical object references.e,g.static class testobjectreference { @suppresswarnings(""unused"") private testobjectreference reference; @suppresswarnings(""unused"") private testobject one; public testobjectreference(int one) { this.one = new testobject(one); } public void setobjectreference( testobjectreference reference) { this.reference = reference; } @override public boolean equals(object obj) { return equalsbuilder.reflectionequals(this, obj); } } "
42,42,"4 0.2047389003910743, 0 0.20312859443294226, 6 0.19588221762134805, 3 0.16287094547964112, 2 0.09201748332183114, 5 0.08235564757303887, 1 0.05900621118012421","stringutils.containsany methods incorrectly matches unicode 2.0+ supplementary characters.for example, define a test fixture to be the unicode character u+20000 where u+20000 is written in java source as ""\ud840\udc00"" private static final string charu20000 = ""\ud840\udc00""; private static final string charu20001 = ""\ud840\udc01"";you can see unicode supplementary characters correctly implemented in the jre call: assertequals(-1, charu20000.indexof(charu20001));but this is broken: assertequals(false, stringutils.containsany(charu20000, charu20001)); assertequals(false, stringutils.containsany(charu20001, charu20000));this is fine: assertequals(true, stringutils.contains(charu20000 + charu20001, charu20000)); assertequals(true, stringutils.contains(charu20000 + charu20001, charu20001)); assertequals(true, stringutils.contains(charu20000, charu20000)); assertequals(false, stringutils.contains(charu20000, charu20001));because the method calls the jre to perform the match.more than you want to know:- http://java.sun.com/developer/technicalarticles/intl/supplementary/ "
43,43,"4 0.3471464921846602, 2 0.1461286804798255, 6 0.1444323276384345, 3 0.13679873985217494, 0 0.07827456682418511, 5 0.07742639040348961, 1 0.06979280261723007","supplementary characters in utf-16 are those whose code points are above 0xffff, that is, require more than 1 java char to be encoded, as explained here: http://java.sun.com/developer/technicalarticles/intl/supplementary/currently, stringescapeutils.escapexml() isnt aware of this coding scheme and treats each char as one character, which is not always right.a possible solution in class entities would be: public void escape(writer writer, string str) throws ioexception { int len = str.length(); for (int i = 0; i < len; i++) { int code = str.codepointat(i); string entityname = this.entityname(code); if (entityname != null) { writer.write(&); writer.write(entityname); writer.write(;); } else if (code > 0x7f) { writer.write(""&#""); writer.write(code); writer.write(;); } else { writer.write((char) code); } if (code > 0xffff) { i++; } } }besides fixing escapexml(), this will also affect html escaping functions. i guess thats a good thing, but please remember i have only tested escapexml(). "
44,44,"4 0.3041157465936227, 1 0.269700800674252, 0 0.14285714285714285, 3 0.08091024020227558, 6 0.07206068268015169, 5 0.06714426183452732, 2 0.06321112515802782",can be replicated in the android emulator quite easily.stack trace:{noformat}at org.apache.commons.lang.builder.tostringbuilder.<clinit>(tostringbuilder.java:98)e/androidruntime( 1681): ... 17 moree/androidruntime( 1681): caused by: java.lang.exceptionininitializererrore/androidruntime( 1681): at org.apache.commons.lang.builder.tostringstyle$multilinetostringstyle.<init>(tostringstyle.java:2276)e/androidruntime( 1681): at org.apache.commons.lang.builder.tostringstyle.<clinit>(tostringstyle.java:94)e/androidruntime( 1681): ... 18 moree/androidruntime( 1681): caused by: java.lang.stringindexoutofboundsexceptione/androidruntime( 1681): at java.lang.string.substring(string.java:1571)e/androidruntime( 1681): at org.apache.commons.lang.systemutils.getjavaversionasfloat(systemutils.java:1153)e/androidruntime( 1681): at org.apache.commons.lang.systemutils.<clinit>(systemutils.java:818){noformat} 
45,45,"3 0.23979591836734696, 4 0.2252456538170824, 0 0.18291761148904007, 1 0.09693877551020405, 2 0.0850340136054422, 5 0.0850340136054422, 6 0.0850340136054422","findbugs:mutable.mutableobject defines equals(mutableobject) method and uses object.equals(object)this class defines a covariant version of the equals() method, but inherits the normal equals(object) method defined in the base java.lang.object class. the class should probably define a boolean equals(object) method. "
46,46,"0 0.18973214285714285, 2 0.17410714285714282, 4 0.1550099206349206, 3 0.12723214285714282, 5 0.12723214285714282, 1 0.1150793650793651, 6 0.11160714285714288","the parameter ""comparetransients"" is ignored and false is always used, as a short look in the code shows:{quote} return reflectioncompare(lhs, rhs, false, reflectuptoclass, null);{quote} "
47,47,"3 0.19950738916256155, 2 0.19663382594417075, 1 0.14874110563765733, 4 0.14203612479474548, 0 0.129584017515052, 6 0.10563765736179527, 5 0.0778598795840175","findbugs:bug: org.apache.commons.lang3.text.extendedmessageformat doesnt override java.text.messageformat.equals(object)pattern id: eq_doesnt_override_equals, type: eq, category: stylethis class extends a class that defines an equals method and adds fields, but doesnt define an equals method itself. thus, equality on instances of this class will ignore the identity of the subclass and the added fields. be sure this is what is intended, and that you dont need to override the equals method. even if you dont need to override the equals method, consider overriding it anyway to document the fact that the equals method for the subclass just return the result of invoking super.equals(o). "
48,48,"6 0.210189452124936, 5 0.13312852022529442, 0 0.1313364055299539, 1 0.1313364055299539, 2 0.1313364055299539, 3 0.1313364055299539, 4 0.1313364055299539","numberutils createnumber throws a stringindexoutofboundsexception instead of numberformatexception when a string containing both possible exponent indicators is passed in.one example of such a string is ""1ee"" "
49,49,"4 0.16562238930659984, 1 0.15685045948203843, 0 0.14661654135338345, 3 0.14661654135338345, 2 0.14223057644110276, 5 0.13345864661654136, 6 0.10860484544695069",1.1l is not a java number . but numberutils.isnumber(string) return true.perhaps change:{code:java} if (chars[i] == l || chars[i] == l) { // not allowing l with an exponent return founddigit && !hasexp; }{code}to:{code:java} if (chars[i] == l || chars[i] == l) { // not allowing l with an exponent return founddigit && !hasexp && !hasdecpoint; }{code} 
50,50,"0 0.19821912504839337, 3 0.1711188540456833, 6 0.16840882694541232, 2 0.12233836624080525, 4 0.12233836624080525, 1 0.11691831204026325, 5 0.10065814943863723","hi, i think i found a bug in the dateutils class in the method issamelocaltime.example: calendar a = calendar.getinstance();a.settimeinmillis(1297364400000l);calendar b = calendar.getinstance();b.settimeinmillis(1297321200000l);assert.assertfalse(dateutils.issamelocaltime(a, b));this is because the method compares cal1.get(calendar.hour) == cal2.get(calendar.hour) but i think it has to be cal1.get(calendar.hour_of_day) == cal2.get(calendar.hour_of_day) "
51,51,"0 0.1966765873015873, 2 0.14459325396825393, 4 0.14285714285714282, 5 0.14285714285714282, 6 0.13417658730158727, 3 0.12723214285714282, 1 0.11160714285714288","equalsbuilder synchronizes on hashcodebuilder.class for updates to its own threadlocal registry variable. while this should not lead to malfunction, it looks like a copy&paste oversight. "
52,52,"1 0.256838905775076, 4 0.20955758189800744, 0 0.182370820668693, 3 0.10199257007767645, 6 0.08780817291455588, 2 0.08544410672070245, 5 0.07598784194528878","after executing linestringutils.replaceeachrepeatedly(""aaa"", new string[]{""aa""}, new string[]{""axa""});exception is thrown:exception in thread ""main"" java.lang.illegalstateexception: timetolive of -1 is less than 0: axaxa at org.apache.commons.lang.stringutils.replaceeach(stringutils.java:3986) at org.apache.commons.lang.stringutils.replaceeach(stringutils.java:4099) at org.apache.commons.lang.stringutils.replaceeach(stringutils.java:4099) at org.apache.commons.lang.stringutils.replaceeachrepeatedly(stringutils.java:3920) "
53,53,"0 0.23106288929073743, 3 0.17902350813743217, 6 0.15089411291942936, 2 0.12698412698412698, 4 0.11854530841872613, 5 0.10307414104882458, 1 0.09041591320072336","method createnumber from numberutils is trying to parse a string with a floating point number always first as a float, that will cause that if we send a string with a number that will need a double or even a bigdecimal the number will be truncate to accommodate into the float without an exception to be thrown, so in fact we will no be returning ever neither a double nor a bigdecimal. "
54,54,"2 0.18764948901935205, 4 0.17851706892802785, 0 0.14503152859317242, 3 0.14046531854751032, 5 0.12524461839530332, 1 0.11154598825831703, 6 0.11154598825831703","try{code} stringutils.join(new object[]{ new object() { @override public string tostring() { return null; } } }, ,);{code}tostring should probably never return null, but it does in javax.mail.internet.internetaddress "
55,55,"1 0.3249299719887956, 0 0.19638966697790228, 3 0.13865546218487393, 4 0.09943977591036413, 6 0.09072517896047305, 2 0.07983193277310922, 5 0.07002801120448181","when calling unescapehtml4() on the string """" (or any string that contains these characters) an exception is thrown:exception in thread ""main"" java.lang.stringindexoutofboundsexception: string index out of range: 4 at java.lang.string.charat(string.java:686) at org.apache.commons.lang3.text.translate.numericentityunescaper.translate(numericentityunescaper.java:49) at org.apache.commons.lang3.text.translate.aggregatetranslator.translate(aggregatetranslator.java:53) at org.apache.commons.lang3.text.translate.charsequencetranslator.translate(charsequencetranslator.java:88) at org.apache.commons.lang3.text.translate.charsequencetranslator.translate(charsequencetranslator.java:60) at org.apache.commons.lang3.stringescapeutils.unescapehtml4(stringescapeutils.java:351) "
56,56,"1 0.2771272443403592, 0 0.19971376528753582, 4 0.19880301847514967, 2 0.10135310954983086, 6 0.08951340098881082, 3 0.07494145199063232, 5 0.058548009367681515","in the static initializer of org.apache.commons.lang3.stringutils, there is an attempt to load the class sun.text.normalizer.such a class is prohibited on google app engine, and the static intializer throws a java.security.accesscontrolexception.{code}caused by: java.security.accesscontrolexception: access denied (java.lang.runtimepermission accessclassinpackage.sun.text) at java.security.accesscontrolcontext.checkpermission(accesscontrolcontext.java:374) at java.security.accesscontroller.checkpermission(accesscontroller.java:546) at java.lang.securitymanager.checkpermission(securitymanager.java:532) at com.google.appengine.tools.development.devappserverfactory$customsecuritymanager.checkpermission(devappserverfactory.java:166) at java.lang.securitymanager.checkpackageaccess(securitymanager.java:1512) at java.lang.class.checkmemberaccess(class.java:2164) at java.lang.class.getmethod(class.java:1602) at org.apache.commons.lang3.stringutils.<clinit>(stringutils.java:739){code}the exception should be caught in the catch clauses around loadclass(""sun.text.normalizer"").commons lang 2 worked fine on gae. "
57,57,"3 0.1597883597883598, 2 0.15238095238095237, 6 0.14867724867724869, 4 0.14497354497354498, 0 0.13571428571428573, 1 0.13571428571428573, 5 0.1227513227513228",numberutils.createnumber() should work equally for 0x1234 and 0x1234; currently 0x1234 generates a numberformatexceptioninteger.decode() handles both upper and lower case hex. 
58,58,"3 0.19785153118486448, 0 0.18213884880551545, 4 0.17203783870450534, 2 0.12602212602212598, 6 0.1237774571107904, 5 0.1136764470097803, 1 0.0844957511624178","numberutils.createlong() does not handle hex numbers, but createinteger() handles hex and octal.this seems odd.numberutils.createnumber() assumes that hex numbers can only be integer.again, why not handle bigger hex numbers?==it is trivial to fix createlong() - just use long.decode() instead of valueof().its not clear why this was not done originally - the decode() method was added to both integer and long in java 1.2.fixing createnumber() is also fairly easy - if the hex string has more than 8 digits, use long.should we allow for leading zeros in an integer? if not, the length check is trivial. "
59,59,"0 0.26639596407038274, 6 0.19662852220991758, 2 0.16131413805832412, 4 0.13030638612033962, 3 0.08982404331241539, 1 0.08637873754152824, 5 0.0691522086870924","similar issue as https://issues.apache.org/jira/browse/httpclient-471following line throws an parseexception on a german system:d = dateutils.parsedate(""wed, 09 apr 2008 23:55:38 gmt"", new string[] {""eee, dd mmm yyyy hh:mm:ss zzz""});reason: parsedate internally calls simpledateformat without providing a locale. this causes ""mmm"" to be interpreted using the system locale. if the system is german, the date is trying to be interpreted as german date.i see following solutions: a) always instantiate simpledateformat with locale.english b) make two instances of simpledateformat. one without providing a locale and one with locale.english. try two parsings c) make as many simpledateformat instances as locales are availble iterate over all instances at the parsing attempts. d) provide an additional (optional) parameter to parsedate for providing a localei would prefer b) as this seems the best trade-off between internationalization and local usage.what do you think? "
60,60,"0 0.22619047619047622, 2 0.21532091097308492, 4 0.1790890269151139, 1 0.10300207039337472, 3 0.09937888198757762, 5 0.08850931677018634, 6 0.08850931677018634",in commons-lang 2.6 line 250 :{code}ch = chars[random.nextint(gap) + start];{code}-this line of code takes a random int to fetch a char in the _chars_ array regardless of its size.--(besides _start_ is useless here)--fixed version would be :-{code}//ch = chars[random.nextint(gap)%chars.length];{code}when user pass 0 as _end_ or when the array is not null but empty this line ends up with an exception 
61,61,"6 0.18123667377398722, 4 0.16631130063965882, 0 0.15138592750533048, 1 0.13646055437100213, 3 0.13646055437100213, 2 0.12153518123667376, 5 0.10660980810234544","randomutils invokes random#nextint(n) where n = end - start.if end <= start, then random throws:java.lang.illegalargumentexception: n must be positivethis is confusing, and does not identify the source of the problem. "
62,62,"0 0.18973214285714285, 3 0.15848214285714285, 4 0.15848214285714285, 2 0.14285714285714282, 1 0.12723214285714282, 5 0.11160714285714288, 6 0.11160714285714288",this looks like a regression from .lang versions prior to 3. if the 2 given charsequences are strings (and both not null) you should check reference equality before delegating to regionmatches() 
63,63,"0 0.23106168615150652, 6 0.19380287044957706, 2 0.18581883851344927, 4 0.13458796692329625, 1 0.09134112726927096, 5 0.09067579127459365, 3 0.07271171941830622","the work on lang-462 has introduced a time zone formatting bug in fastdateformat in commons-lang3.the problem can be seen by this snippet:{code}// always prints timezone name of machines default timezone, ignoring tz// set on calendar, even though the printed time itself respects calendars tz.calendar mycal = calendar.getinstance(timezone.gettimezone(""us/central""));system.out.println(fastdateformat.getinstance(""h:mma z"").format(mycal));{code}if you happen to be in us/central, this will print the right thing, but just try it with us/eastern, us/pacific, etc. it will print the time in the correct timezone, but the timezone name at the end (the ""z"" pattern) will always be the system default timezone. this is a regression against commons-lang 2.x.basically, when the ""forced time zone"" code was removed, the timezonenamerule class stopped respecting the calendar instances timezone, and instead now always uses the mtimezone of the fastdateformat instance itself (which is only supposed to be used when formatting timezone-less objects such as date or long).the removal of the forced time zone stuff is surely the right thing to do (it was a mess). i think the fix is to change the timezonenamerule inner class to not take a timezone instance, but rather to use the timezone on the calendar instance passed into appendto(), just like timezonenumberrule does. presumably then for efficiency, one would use the gettimezonedisplay() package-static method to quickly retrieve the required timezones display name. "
64,64,"0 0.2642857142857143, 2 0.16706349206349205, 3 0.1392857142857143, 5 0.11845238095238093, 6 0.1101190476190476, 1 0.10178571428571427, 4 0.09900793650793649","numberutils#createnumber checks for a leading ""--"" in the string, and returns null if found. this is documented as a work round for a bug in bigdecimal.returning nulll is contrary to the javadoc and the behaviour for other methods which would throw numberformatexception.its not clear whether the bigdecimal problem still exists with recent versions of java. however, if it does exist, then the check needs to be done for all invocations of bigdecimal, i.e. needs to be moved to createbigdecimal. "
65,65,"6 0.2420634920634921, 3 0.15734126984126984, 2 0.14761904761904762, 4 0.13095238095238093, 5 0.11428571428571427, 1 0.10734126984126982, 0 0.10039682539682539",the following calendars are non-gregorian [1]:ja_jp_jp - japanese imperial)th_th (with any variant) - thai buddhistthis causes errors when testing round-trip conversions.the simplest solution is to fall back to simpledateformat for these calendars.[1] http://docs.oracle.com/javase/6/docs/technotes/guides/intl/calendar.doc.html 
66,66,"2 0.21440416962805026, 0 0.1779199241885809, 5 0.14309405354181473, 6 0.12982705520018953, 3 0.12153518123667377, 1 0.10660980810234545, 4 0.10660980810234545",fdp does not handled unterminated quotes the same way as simpledateformatfor example:format: \d\d\date: d3this should fail to parse the format and date but it actually works.the format is parsed as:pattern: d(\\p{isnd}++) 
67,67,"3 0.21253968253968256, 0 0.2080952380952381, 2 0.18698412698412697, 4 0.15142857142857144, 6 0.08587301587301585, 1 0.08365079365079363, 5 0.07142857142857144","the private method removeall(object array, int... indices) sorts the indices array, so arrays passed in by application code need to be cloned first.however, where the index array is generated locally, that is unnecessary.the removeelements() methods currently call the public removeall(<type>[] array, int... indices) methods, which clone the indices before calling the private removeall() method.the removeelements() methods should call the private method directly, avoiding the unnecessary clone call. "
68,68,"1 0.23756982467783863, 0 0.19943587190973952, 2 0.17988496211492727, 3 0.1372988219678115, 6 0.12858802057408328, 4 0.0707095846468669, 5 0.04651291410873293","the test below fails with the following error on jdk7, but succeeds on jdk6:testalllocales""java.lang.assertionerror: expected: <ja_jp_jp_#u-ca-japanese> but: was <ja_jp_jp_#u-ca-japanese> at org.hamcrest.matcherassert.assertthat(matcherassert.java:20) at org.hamcrest.matcherassert.assertthat(matcherassert.java:8) at com.scispike.foundation.test.unit.i18n.localestringconvertertest.teststringtolocale(localestringconvertertest.java:20) at com.scispike.foundation.test.unit.i18n.localestringconvertertest.testalllocales(localestringconvertertest.java:28) at org.apache.maven.surefire.testng.testngexecutor.run(testngexecutor.java:76) at org.apache.maven.surefire.testng.testngdirectorytestsuite.executemulti(testngdirectorytestsuite.java:161) at org.apache.maven.surefire.testng.testngdirectorytestsuite.execute(testngdirectorytestsuite.java:101) at org.apache.maven.surefire.testng.testngprovider.invoke(testngprovider.java:115) at org.apache.maven.surefire.util.reflectionutils.invokemethodwitharray(reflectionutils.java:189) at org.apache.maven.surefire.booter.providerfactory$providerproxy.invoke(providerfactory.java:165) at org.apache.maven.surefire.booter.providerfactory.invokeprovider(providerfactory.java:85) at org.apache.maven.surefire.booter.forkedbooter.runsuitesinprocess(forkedbooter.java:103) at org.apache.maven.surefire.booter.forkedbooter.main(forkedbooter.java:74)... removed 25 stack frames java.lang.assertionerror: expected: <ja_jp_jp_#u-ca-japanese> but: was <ja_jp_jp_#u-ca-japanese> at org.hamcrest.matcherassert.assertthat(matcherassert.java:20) at org.hamcrest.matcherassert.assertthat(matcherassert.java:8) at com.scispike.foundation.test.unit.i18n.localestringconvertertest.teststringtolocale(localestringconvertertest.java:20) at com.scispike.foundation.test.unit.i18n.localestringconvertertest.testalllocales(localestringconvertertest.java:28) at sun.reflect.nativemethodaccessorimpl.invoke0(native method) at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:57) at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43) at java.lang.reflect.method.invoke(method.java:601) at org.testng.internal.methodinvocationhelper.invokemethod(methodinvocationhelper.java:80) at org.testng.internal.invoker.invokemethod(invoker.java:715) at org.testng.internal.invoker.invoketestmethod(invoker.java:907) at org.testng.internal.invoker.invoketestmethods(invoker.java:1237) at org.testng.internal.testmethodworker.invoketestmethods(testmethodworker.java:127) at org.testng.internal.testmethodworker.run(testmethodworker.java:111) at org.testng.testrunner.privaterun(testrunner.java:767) at org.testng.testrunner.run(testrunner.java:617) at org.testng.suiterunner.runtest(suiterunner.java:334) at org.testng.suiterunner.runsequentially(suiterunner.java:329) at org.testng.suiterunner.privaterun(suiterunner.java:291) at org.testng.suiterunner.run(suiterunner.java:240) at org.testng.suiterunnerworker.runsuite(suiterunnerworker.java:51) at org.testng.suiterunnerworker.run(suiterunnerworker.java:85) at org.testng.testng.runsuitessequentially(testng.java:1197) at org.testng.testng.runsuiteslocally(testng.java:1122) at org.testng.testng.run(testng.java:1030) at org.apache.maven.surefire.testng.testngexecutor.run(testngexecutor.java:76) at org.apache.maven.surefire.testng.testngdirectorytestsuite.executemulti(testngdirectorytestsuite.java:161) at org.apache.maven.surefire.testng.testngdirectorytestsuite.execute(testngdirectorytestsuite.java:101) at org.apache.maven.surefire.testng.testngprovider.invoke(testngprovider.java:115) at sun.reflect.nativemethodaccessorimpl.invoke0(native method) at sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:57) at sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43) at java.lang.reflect.method.invoke(method.java:601) at org.apache.maven.surefire.util.reflectionutils.invokemethodwitharray(reflectionutils.java:189) at org.apache.maven.surefire.booter.providerfactory$providerproxy.invoke(providerfactory.java:165) at org.apache.maven.surefire.booter.providerfactory.invokeprovider(providerfactory.java:85) at org.apache.maven.surefire.booter.forkedbooter.runsuitesinprocess(forkedbooter.java:103) at org.apache.maven.surefire.booter.forkedbooter.main(forkedbooter.java:74)""org.hamcrest.matcherassert.assertthat(matcherassert.java:20)org.hamcrest.matcherassert.assertthat(matcherassert.java:8)com.scispike.foundation.test.unit.i18n.localestringconvertertest.teststringtolocale(localestringconvertertest.java:20)com.scispike.foundation.test.unit.i18n.localestringconvertertest.testalllocales(localestringconvertertest.java:28)sun.reflect.nativemethodaccessorimpl.invoke0(native method)sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:57)sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)java.lang.reflect.method.invoke(method.java:601)org.testng.internal.methodinvocationhelper.invokemethod(methodinvocationhelper.java:80)org.testng.internal.invoker.invokemethod(invoker.java:715)org.testng.internal.invoker.invoketestmethod(invoker.java:907)org.testng.internal.invoker.invoketestmethods(invoker.java:1237)org.testng.internal.testmethodworker.invoketestmethods(testmethodworker.java:127)org.testng.internal.testmethodworker.run(testmethodworker.java:111)org.testng.testrunner.privaterun(testrunner.java:767)org.testng.testrunner.run(testrunner.java:617)org.testng.suiterunner.runtest(suiterunner.java:334)org.testng.suiterunner.runsequentially(suiterunner.java:329)org.testng.suiterunner.privaterun(suiterunner.java:291)org.testng.suiterunner.run(suiterunner.java:240)org.testng.suiterunnerworker.runsuite(suiterunnerworker.java:51)org.testng.suiterunnerworker.run(suiterunnerworker.java:85)org.testng.testng.runsuitessequentially(testng.java:1197)org.testng.testng.runsuiteslocally(testng.java:1122)org.testng.testng.run(testng.java:1030)org.apache.maven.surefire.testng.testngexecutor.run(testngexecutor.java:76)org.apache.maven.surefire.testng.testngdirectorytestsuite.executemulti(testngdirectorytestsuite.java:161)org.apache.maven.surefire.testng.testngdirectorytestsuite.execute(testngdirectorytestsuite.java:101)org.apache.maven.surefire.testng.testngprovider.invoke(testngprovider.java:115)sun.reflect.nativemethodaccessorimpl.invoke0(native method)sun.reflect.nativemethodaccessorimpl.invoke(nativemethodaccessorimpl.java:57)sun.reflect.delegatingmethodaccessorimpl.invoke(delegatingmethodaccessorimpl.java:43)java.lang.reflect.method.invoke(method.java:601)org.apache.maven.surefire.util.reflectionutils.invokemethodwitharray(reflectionutils.java:189)org.apache.maven.surefire.booter.providerfactory$providerproxy.invoke(providerfactory.java:165)org.apache.maven.surefire.booter.providerfactory.invokeprovider(providerfactory.java:85)org.apache.maven.surefire.booter.forkedbooter.runsuitesinprocess(forkedbooter.java:103)org.apache.maven.surefire.booter.forkedbooter.main(forkedbooter.java:74)========== testimport static org.hamcrest.matcherassert.assertthat;import static org.hamcrest.matchers.equalto;import java.util.locale;import org.testng.annotations.test;import com.scispike.foundation.i18n.stringtolocaleconverter;public class localestringconvertertest { stringtolocaleconverter converter = new stringtolocaleconverter(); public void teststringtolocale(locale l) { string s = l.tostring(); assertthat(converter.convert(s), equalto(l)); } @test public void testalllocales() { locale[] locales = locale.getavailablelocales(); for (locale l : locales) { teststringtolocale(l); } }}========== stringtolocaleconverterimport java.util.locale;import org.apache.commons.lang3.localeutils;import org.springframework.core.convert.converter.converter;public class stringtolocaleconverter implements converter<string, locale> { @override public locale convert(string source) { if (source == null) { return localetostringconverter.default; } return localeutils.tolocale(source); }} "
69,69,"6 0.17334341143864954, 0 0.16452506928697405, 2 0.14512471655328796, 3 0.14512471655328796, 4 0.1292517006802721, 5 0.1292517006802721, 1 0.11337868480725626","the javadoc for numberutils.createnumber() states:""values with leading 0\s will not be interpreted as octal.""however,assertequals(25, numberutils.createnumber(""0025""));fails, because numberutils.createnumber(""0025"") returns 21. "
70,70,"0 0.2020757020757021, 3 0.19993894993894998, 2 0.18658424908424914, 4 0.15079365079365079, 6 0.11553724053724053, 1 0.08615689865689866, 5 0.058913308913308905","the core of {{org.apache.commons.lang3.text.translate}} is a {{hashmap<charsequence, charsequence> lookupmap}}.from the javadoc of {{charsequence}} (emphasis mine):{quote}this interface does not refine the general contracts of the equals and hashcode methods. the result of comparing two objects that implement charsequence is therefore, in general, undefined. each object may be implemented by a different class, and there is no guarantee that each class will be capable of testing its instances for equality with those of the other. *it is therefore inappropriate to use arbitrary charsequence instances as elements in a set or as keys in a map.*{quote}the current implementation causes code such as the following to not work as expected:{code}charsequence cs1 = ""1 < 2"";charsequence cs2 = charbuffer.wrap(""1 < 2"".tochararray());system.out.println(stringescapeutils.escape_html4.translate(cs1));system.out.println(stringescapeutils.escape_html4.translate(cs2));{code}... which gives the following results (but should be identical):{noformat}1 < 21 < 2{noformat}the problem, at a minimum, is that {{charbuffer.equals}} is even documented in the javadoc that:{quote}a char buffer is not equal to any other type of object.{quote}... so a lookup on a charbuffer in the map will always fail when compared against the string implementations that it contains.an obvious work-around is to instead use something along the lines of either of the following:{code}system.out.println(stringescapeutils.escape_html4.translate(cs2.tostring()));system.out.println(stringescapeutils.escapehtml4(cs2.tostring()));{code}... which forces everything back to a {{string}}. however, this is not practical when working with large sets of data, which would require significant heap allocations and garbage collection concerns. (as such, i was actually trying to use the {{translate}} method that outputs to a {{writer}} - but simplified the above examples to omit this.)another option that im considering is to use a custom {{charsequence}} wrapper around a {{char[]}} that implements {{hashcode()}} and {{equals()}} to work with those implemented on {{string}}. (however, this will be interesting due to the symmetric assumption - which is further interesting that {{string.equals}} is currently implemented using {{instanceof}} - even though {{string}} is {{final}}...) "
71,71,"4 0.212533498247784, 3 0.16924345495774068, 0 0.14471243042671614, 2 0.1302824159967017, 5 0.1302824159967017, 1 0.12018140589569161, 6 0.09276437847866421","endswithany was added in response to this task: lang-614documentation says that the method returns ""true if the charsequence starts with any of the the prefixes, case insensitive, or both null"" stringutils.endswithany(""mime/type"", ""type"") truestringutils.endswithany(""mime/type"", ""type"") false "
72,72,"3 0.17863441672965485, 4 0.16099773242630386, 0 0.15217939027462837, 6 0.15217939027462837, 2 0.1292517006802721, 1 0.11337868480725627, 5 0.11337868480725627","the static method localeutils.tolocale() fails, at least, to parse 3-char locale strings, which are completelly valid bcp47 locales. "
73,73,"0 0.47378739012205145, 3 0.10990956807689875, 5 0.10813887307911212, 6 0.09707202934294568, 4 0.08866122810345918, 2 0.06785556187946626, 1 0.054575349396066515","in lang-538 issue, there is an unit test:{noformat} public void testformat_calendarisomszulu() { final string datetime = ""2009-10-16t16:42:16.000z""; gregoriancalendar cal = new gregoriancalendar(timezone.gettimezone(""gmt-8"")); cal.clear(); cal.set(2009, 9, 16, 8, 42, 16); cal.gettime(); fastdateformat format = fastdateformat.getinstance(""yyyy-mm-ddthh:mm:ss.sssz"", timezone.gettimezone(""gmt"")); assertequals(""datetime"", datetime, format.format(cal)); }{noformat}this test passes successfully in lang-2.6 but failed in lang3-3.1:{noformat}org.junit.comparisonfailure: datetime expected:<2009-10-16t[16]:42:16.000z> but was:<2009-10-16t[08]:42:16.000z>{noformat}reproduced whit sun java version: 1.6.0_45 and 1.7.0_21 on fedora 17 (linux 3.9.10-100.fc17.i686.pae).moreover, i wrote another unit test showing that the timezone parameter seems to be ignored :{noformat}public void test() { calendar cal = calendar.getinstance(timezone.gettimezone(""europe/paris"")); cal.set(2009, 9, 16, 8, 42, 16); // system.out.println(dateformatutils.iso_datetime_time_zone_format.format(cal)); system.out.println(""long""); system.out.println(dateformatutils.format(cal.gettimeinmillis(), dateformatutils.iso_datetime_time_zone_format.getpattern(), timezone.getdefault())); system.out.println(dateformatutils.format(cal.gettimeinmillis(), dateformatutils.iso_datetime_time_zone_format.getpattern(), timezone.gettimezone(""asia/kolkata""))); system.out.println(dateformatutils.format(cal.gettimeinmillis(), dateformatutils.iso_datetime_time_zone_format.getpattern(), timezone.gettimezone(""europe/london""))); system.out.println(""calendar""); system.out.println(dateformatutils.format(cal, dateformatutils.iso_datetime_time_zone_format.getpattern(), timezone.getdefault())); system.out.println(dateformatutils.format(cal, dateformatutils.iso_datetime_time_zone_format.getpattern(), timezone.gettimezone(""asia/kolkata""))); system.out.println(dateformatutils.format(cal, dateformatutils.iso_datetime_time_zone_format.getpattern(), timezone.gettimezone(""europe/london""))); system.out.println(""calendar fast""); system.out.println(fastdateformat.getinstance(""yyyy-mm-ddthh:mm:ss.sssz"", timezone.gettimezone(""europe/paris"")).format(cal)); system.out.println(fastdateformat.getinstance(""yyyy-mm-ddthh:mm:ss.sssz"", timezone.gettimezone(""asia/kolkata"")).format(cal)); system.out.println(fastdateformat.getinstance(""yyyy-mm-ddthh:mm:ss.sssz"", timezone.gettimezone(""europe/london"")).format(cal));}{noformat}gives the following console logs:{noformat}long2009-10-16t08:42:16+02:002009-10-16t12:12:16+05:302009-10-16t07:42:16+01:00calendar2009-10-16t08:42:16+02:002009-10-16t08:42:16+02:002009-10-16t08:42:16+02:00calendar fast2009-10-16t08:42:16.975z2009-10-16t08:42:16.975z2009-10-16t08:42:16.975z{noformat}when dateformatutils.format takes a long parameter, the time string is good.when dateformatutils.format takes a calendar parameter, the time string is wrong, the timezone parameter is ignored. "
74,74,"1 0.19580952380952385, 4 0.18069841269841272, 0 0.1655873015873016, 3 0.13536507936507938, 2 0.11847619047619048, 6 0.10780952380952381, 5 0.09625396825396824","when using a custom format registered and a choice format with an inner format is used in the same message format, an indexoutofboundsexception occurs in the custructor of extendedmessageformat:{code:java}new extendedmessageformat(""hi {0,test,any}, got {1,choice,0#none|1#one|1<{1,number}}"", collections.singletonmap(""test"", new testformatfactory()));{code}{noformat}java.lang.indexoutofboundsexception: index: 2, size: 2 at java.util.arraylist.rangecheck(arraylist.java:604) at java.util.arraylist.get(arraylist.java:382) at org.apache.commons.lang.text.extendedmessageformat.insertformats(extendedmessageformat.java:364) at org.apache.commons.lang.text.extendedmessageformat.applypattern(extendedmessageformat.java:192) at org.apache.commons.lang.text.extendedmessageformat.<init>(extendedmessageformat.java:127){noformat}the problem occurs at the start of {{\{1,number\}}}.as a workaround i registered the {{testformatfactory}} also for ""choice"" and then returning {{new choiceformat(arguments)}}, but that is not the idea.i also checked the change logs, but there seems no change on this problem. i have not tester, but i think the bug still is present in the current release. "
75,75,"4 0.23878536922015187, 0 0.14699792960662525, 3 0.14216701173222912, 6 0.13250517598343686, 2 0.11801242236024843, 5 0.11801242236024843, 1 0.10351966873706007","booleanutils.xor(true, true, false, true) returns false, although true ^ true ^ false ^ true is true. this is because the implementation only checks the count of true in the provided array. "
76,76,"6 0.19585253456221194, 0 0.19406041986687145, 2 0.1313364055299539, 3 0.13133640552995388, 1 0.11699948796722992, 4 0.11520737327188942, 5 0.11520737327188942",add a method which allows to remove the final modifier from a fieldsee http://goo.gl/jo1vjh for further details. 
77,77,"4 0.1693121693121693, 2 0.1658399470899471, 0 0.1496362433862434, 3 0.14500661375661375, 6 0.13574735449735448, 1 0.12880291005291003, 5 0.10565476190476189","stringutils.getlevenshteindistance(charsequence s, charsequence t, int threshold) specifies:{quote}{{find the levenshtein distance between two strings if its _+*less than or equal to*+_ a given threshold.}}{quote}when passing a threshold > *integer.max_value - max(s.length(), t.length())* the method always returns -1.the simplest use case is passing *integer.max_value* (a common practice if one would want to find the min/max ld of a string to several other strings in an iterative fashion.the code should be fixed to consider the threshold in relation to the source/target lengths, or alternatively the javadoc should be fixed to pronounce the current limit. "
78,78,"1 0.31495405179615704, 6 0.1441938178780284, 0 0.131328320802005, 3 0.10676691729323307, 4 0.10676691729323307, 2 0.09974937343358395, 5 0.09624060150375938","exception while trying to format a string containing escaped braces{code}exception in thread ""main"" java.lang.illegalargumentexception: invalid format argument index at position 7: } at org.apache.commons.lang3.text.extendedmessageformat.readargumentindex(extendedmessageformat.java:357) at org.apache.commons.lang3.text.extendedmessageformat.applypattern(extendedmessageformat.java:167) at org.apache.commons.lang3.text.extendedmessageformat.<init>(extendedmessageformat.java:128) at org.apache.commons.lang3.text.extendedmessageformat.<init>(extendedmessageformat.java:113) at test.testextendedmessageformat.main(testextendedmessageformat.java:16){code}i will attach a source "
79,79,"0 0.2500575109270762, 2 0.15504945939728546, 3 0.14699792960662522, 4 0.13089487002530478, 6 0.10835058661145619, 1 0.1051299746951921, 5 0.10351966873706006",simpledateformat has a set2digityearstart(date startdate) method to determine the start of the default century. fastdateparser uses a static 80 years in the past as the default century start.the application should be able to set the default century as part of the constructor. 
80,80,"0 0.24011085915847818, 6 0.19072814310909547, 3 0.16691861929957166, 4 0.12106324011085914, 2 0.11400856638951876, 5 0.08931720836482739, 1 0.07785336356764926","when one trys to get the fragments of a calendar object and uses the fragment year or month, the returned value is wrong by 1 day in the targeted timeunit. the bug resides in the class *dateutils* in function {code}private static long getfragment(calendar calendar, int fragment, int unit){code}there is an initial recalculation if the fragment is year or month. so if one would like to have the minutes for the fragment year for the date 2000-01-01 00:00:00 this would return 1440 which is actually wrong. the error can be found on lines 1635 - 1643.suggested fix:{code}// fragments bigger than a day require a breakdown to days switch (fragment) { case calendar.year: result += ((calendar.get(calendar.day_of_year)-1) * millis_per_day) / millisperunit; break; case calendar.month: result += ((calendar.get(calendar.day_of_month)-1) * millis_per_day) / millisperunit; break; }{code} "
81,81,"4 0.19569160997732427, 0 0.15918367346938778, 1 0.14648526077097504, 6 0.14648526077097504, 3 0.13061224489795917, 2 0.11950113378684807, 5 0.10204081632653064","when trying to convert ""0085"" with numberutils.createinteger(string) an numberformatexception is thrown. this is because the leading 0 causes the string to be evaluated as an octal, 8 is not a valid octal.however numberutils#isnumber(string) evaluates to true, even so it cannot be converted. "
82,82,"0 0.17599554441659698, 3 0.17599554441659698, 1 0.13700918964076858, 4 0.1311612364243943, 6 0.1292119186856029, 2 0.12531328320802007, 5 0.12531328320802007",isnumber() does not allow for 0xabcd whereas createnumber() allows for both 0xabcd and 0xabcd 
83,83,"0 0.24050294275013379, 3 0.2018013197788479, 4 0.14999108257535224, 2 0.14811842339932227, 1 0.09693240592116996, 5 0.08507223113964688, 6 0.07758159443552701","numericentityescaper will incorrectly encode supplementary unicode characters depending on the char length of the first code point in the string.to reproduce, run:{code}string escaped = numericentityescaper.between(0x7f, integer.max_value).translate(""a \ud83d\udc14 \ud83d\udca9"");{code}expected:{code}escaped == ""a ð ð©""{code}actual:{code}escaped == ""a ðï¿½ ð©ï¿½""{code}the issue lies in charsequencetranslator.translate() and the way it checks code points to figure out how many characters it needs to consume. specifically, the issue is on [line 95|https://github.com/apache/commons-lang/blob/trunk/src/main/java/org/apache/commons/lang3/text/translate/charsequencetranslator.java#l95]:{code}// contract with translators is that they have to understand codepoints // and they just took care of a surrogate pairfor (int pt = 0; pt < consumed; pt++) { pos += character.charcount(character.codepointat(input, pt));}{code}the point of this code is to check the charcount of the character that was just translated and move ahead by that many characters in the input string. the bug is that its indexing into the string using pt, which is _always_ 0 at the beginning of the loop. its effetively checking the charcount of first character in the string every time.a patch is attached that fixes the issue and includes supporting unit tests. fixing this issue in charsequencetranslator uncovered an issue in csvescaper/csvunescaper caused by the fact that it wasnt respecting the ""code point contract"" described in charsequencetranslator.translate. the fix there was to have the translate methods return the strings code point count rather than character count. "
84,84,"0 0.21280423280423286, 2 0.19354497354497358, 1 0.18391534391534395, 6 0.11947089947089949, 4 0.1031746031746032, 3 0.09724867724867726, 5 0.08984126984126985","gary gregory has reported failing tests during the vote for lang 3.3 rc1, when building with:{code}java version ""1.8.0""java(tm) se runtime environment (build 1.8.0-b128)java hotspot(tm) 64-bit server vm (build 25.0-b69, mixed mode)apache maven 3.2.1 (ea8b2b07643dbb1b84b6d16e1f08391b666bc1e9;2014-02-14t12:37:52-05:00)maven home: c:\java\apache-maven-3.2.1\bin\..java version: 1.8.0, vendor: oracle corporationjava home: c:\program files\java\jdk1.8.0\jredefault locale: en_us, platform encoding: cp1252os name: ""windows 7"", version: ""6.1"", arch: ""amd64"", family: ""dos""{code}{code}fastdateformat_parsertest>fastdateparsertest.testparses:242->fastdateparsertest.validatesdfformatfdpparseequality:219 Â» parse fastdateparsertest.testparses:242->validatesdfformatfdpparseequality:219 Â» parserunning org.apache.commons.lang3.time.fastdateformat_parsertest /1/2/10/5/??/0/0/?/+0000 ja_jp_jp_#u-ca-japanese 1867 g/y/m/d/h/a/m/s/e/z america/new_york tests run: 29, failures: 0, errors: 1, skipped: 0, time elapsed: 2.491 sec <<< failure! - in org.apache.commons.lang3.time.fastdateformat_parsertest testparses(org.apache.commons.lang3.time.fastdateformat_parsertest) time elapsed: 1.492 sec <<< error! java.text.parseexception: (the ja_jp_jp_#u-ca-japanese locale does not support dates before 1868 ad){code}see: http://markmail.org/message/suvorq3xrqmimnui "
85,85,"0 0.1893424036281179, 5 0.18140589569160998, 3 0.15759637188208617, 2 0.1306122448979592, 4 0.12426303854875283, 6 0.11473922902494331, 1 0.10204081632653064","the method durationformatutils#lexx does not detect if the format string contains an unmatched single-quote character.for example ""ymd\test"" should really be rejected, as the literal string ""test"" is not properly terminated. "
86,86,"0 0.2477324263038549, 3 0.2146636432350718, 2 0.12339380196523052, 4 0.1220710506424792, 6 0.10619803476946331, 1 0.09693877551020405, 5 0.08900226757369617","durationformatutils assumes that the the number of days, hours, minutes, seconds and milliseconds can be expressed as an int when converted from a long duration in milliseconds.however even the number of days can exceed an int if the duration is large enough.its unlikely that such large durations will often be used, but this restriction is not documented. it should be easy enough to use long fields instead of int. "
87,87,"0 0.23044421605572687, 3 0.19447299303414411, 6 0.19367363252255337, 2 0.1241292680141601, 1 0.12173118647938792, 5 0.07616763731871644, 4 0.05938106657531116","commons lang3 screwed up my system after upgraded to 3.3 last night!we use dateutils.getfragmentindays(date, calendar.month) to extract days for later use. basically (in 3.2), today (mar. 13) returns 13, but, it returns 12 in 3.3!i compared the underlying method org.apache.commons.lang3.time.dateutils.getfragment(calendar, int, int) between 3.2 and 3.3:3.2{code:java} // fragments bigger than a day require a breakdown to days switch (fragment) { case calendar.year: result += (calendar.get(calendar.day_of_year) * millis_per_day) / millisperunit; break; case calendar.month: result += (calendar.get(calendar.day_of_month) * millis_per_day) / millisperunit; break; }{code}3.3{code:java} // fragments bigger than a day require a breakdown to days switch (fragment) { case calendar.year: result += ((calendar.get(calendar.day_of_year) -1) * millis_per_day) / millisperunit; break; case calendar.month: result += ((calendar.get(calendar.day_of_month) -1) * millis_per_day) / millisperunit; break; default: break; }{code}is there any any reason for adding -1 in 3.3?! plus, do you have any unit test for this method? "
88,88,"0 0.244298485677796, 3 0.16128443714650606, 4 0.13701879219120597, 2 0.12807881773399013, 1 0.12169312169312166, 5 0.10381317277869, 6 0.10381317277869","after upgrading from 3.1 to 3.3.1, it seems that {{isnumber(string str)}} returns false for decimal numbers with leading zeros. in other words:{code:java}boolean ret = numberutils.isnumber(""0.4790"");{code}on 3.1, {{ret}} was true. in 3.3.1, {{ret}} is false.guessing that lang-972 is related... comment in the code states:{code:java}// leading 0, but not hex, must be octal{code}this is clearly a case where leading 0 means neither hex nor octal. "
89,89,"1 0.1831065759637188, 0 0.1454081632653061, 3 0.1454081632653061, 2 0.1414399092970521, 4 0.12953514739229027, 5 0.1275510204081633, 6 0.1275510204081633",via github: https://github.com/apache/commons-lang/pull/18 
90,90,"0 0.19450367211561242, 2 0.16465292584695568, 4 0.14475242833451787, 5 0.13646055437100213, 3 0.12982705520018953, 6 0.12153518123667376, 1 0.1082681828950486","it spits out complete garbage.{code}system.out.println(durationformatutils.formatdurationhms(-3454));system.out.println(durationformatutils.formatperiodiso(4000, 3000));{code}{noformat}0:00:-3.-454p-1y11m30dt23h59m59.000s{noformat}it should throw an {{illegalargumentexception}} if duration is < 0 or period diff is < 0. "
91,91,"0 0.2368032484311554, 3 0.18641565153193063, 2 0.1463639719453673, 6 0.11406423034330009, 4 0.11018826135105203, 5 0.10760428202288665, 1 0.09856035437430784","this method has several flaws:1. javadoc says: ""the format used is iso8601-like: h:m:s.s."" but the method call supplies ""h:mm:ss.sss""2. iso time never omits leading zeros, so the proper pattern must be ""hh:mm:ss.sss""3. the method name says: ""hms"" but includes the second fraction.since the use of fractions is optional, the method should use ""hh:mm:ss"" and update the javadoc as well. "
92,92,"4 0.18260751594084929, 3 0.17026183692850358, 0 0.15601682268348932, 6 0.1522181522181522, 2 0.1427214760548094, 1 0.09903676570343234, 5 0.09713743047076377","with commons-lang 3.2.2:numberutils.createnumber(""-160952.54"");the result is ""-160952.55"".should not be based on the length of the decimal point number to judge whether the floating point number.using the method (createfloat(str)) of dealing with the valid number greater than seven numbers will cause accuracy loss.the source code is as follows:{code:java}try { if(numdecimals <= 7){// if number has 7 or fewer digits past the decimal point then make it a float final float f = createfloat(str); if (!(f.isinfinite() || (f.floatvalue() == 0.0f && !allzeros))) { return f; } } } catch (final numberformatexception nfe) { // nopmd // ignore the bad number } try { if(numdecimals <= 16){// if number has between 8 and 16 digits past the decimal point then make it a double final double d = createdouble(str); if (!(d.isinfinite() || (d.doublevalue() == 0.0d && !allzeros))) { return d; } } } catch (final numberformatexception nfe) { // nopmd // ignore the bad number } return createbigdecimal(str); }{code} "
93,93,"0 0.22320069580343552, 1 0.21787345075016304, 4 0.14253098499673839, 5 0.13796477495107629, 2 0.11969993476842788, 6 0.08469232441835178, 3 0.07403783431180688","strsubsitutor caches a references to systemproperties statically on first class references. this does not work properly with system.setproperties(). for example the following code:{code}package test.utilities;import java.util.properties;import org.apache.commons.lang.text.strsubstitutor;public class teststrsubstitutor { public static void main(string[] args) { system.out.println(strsubstitutor.replacesystemproperties(""os.name=${os.name}"")); properties testprops = new properties(); testprops.put(""test_key"", ""test_value""); testprops.putall(system.getproperties()); system.setproperties(testprops); system.out.println(strsubstitutor.replace(""test_key=${test_key}"", system.getproperties())); system.out.println(strsubstitutor.replacesystemproperties(""test_key=${test_key}"")); }}{code}produces the following output:{code}os.name=windows 7test_key=test_valuetest_key=${test_key}{code}the code linked here shows the static caching of the system properties reference: http://commons.apache.org/proper/commons-lang/apidocs/src-html/org/apache/commons/lang3/text/strlookup.html "
94,94,"4 0.17679255610290093, 3 0.17487684729064037, 6 0.14230979748221126, 1 0.13656267104542968, 0 0.12315270935960596, 2 0.12315270935960596, 5 0.12315270935960596","the isnumber method assumes, that if the string being passed in doesn\t have an \x\ at the second char it is an octal number. "
95,95,"2 0.3573330130707181, 0 0.2750855701675374, 4 0.14001481214595968, 3 0.10316459496787364, 6 0.04767909685942474, 5 0.046978522388358465, 1 0.029744390400128107","the following code throws an exception:dateparser dp = fastdateformat.getinstance(""z yyyy"", locale.us);dp.parse(""gmt+00:00 2010"");the format works correctly with simpledateformat.stack:java.text.parseexception: unparseable date: ""gmt+00:00 2010"" does not match (gmt[+\-]\d{0,1}\d{2}|[+\-]\d{2}:?\d{2}|\qacre time\e|\qact\e|\qadt\e|\qafghanistan time\e|\qaft\e|\qakdt\e|\qakst\e|\qalaska daylight time\e|\qalaska standard time\e|\qalma-ata time\e|\qalmt\e|\qamazon summer time\e|\qamazon time\e|\qamst\e|\qamt\e|\qanadyr time\e|\qanat\e|\qaqtau time\e|\qaqtobe time\e|\qaqtt\e|\qarabia standard time\e|\qargentine time\e|\qarmenia time\e|\qart\e|\qast\e|\qatlantic daylight time\e|\qatlantic standard time\e|\qazerbaijan summer time\e|\qazerbaijan time\e|\qazores summer time\e|\qazores time\e|\qazost\e|\qazot\e|\qazst\e|\qazt\e|\qbangladesh time\e|\qbdt\e|\qbhutan time\e|\qbnt\e|\qbolivia time\e|\qbot\e|\qbrasilia summer time\e|\qbrasilia time\e|\qbritish summer time\e|\qbrst\e|\qbrt\e|\qbrunei time\e|\qbst\e|\qbtt\e|\qcape verde time\e|\qcat\e|\qcct\e|\qcdt\e|\qcentral african time\e|\qcentral daylight time\e|\qcentral european summer time\e|\qcentral european time\e|\qcentral indonesia time\e|\qcentral standard time\e|\qcentral standard time (northern territory)\e|\qcentral standard time (south australia)\e|\qcentral standard time (south australia/new south wales)\e|\qcentral summer time (south australia)\e|\qcentral summer time (south australia/new south wales)\e|\qcentral western standard time (australia)\e|\qcest\e|\qcet\e|\qchadt\e|\qchamorro standard time\e|\qchast\e|\qchatham daylight time\e|\qchatham standard time\e|\qchile summer time\e|\qchile time\e|\qchina standard time\e|\qchoibalsan time\e|\qchot\e|\qchristmas island time\e|\qchst\e|\qchut\e|\qchuuk time\e|\qckt\e|\qclst\e|\qclt\e|\qcocos islands time\e|\qcolombia time\e|\qcook is. time\e|\qcoordinated universal time\e|\qcot\e|\qcst\e|\qcuba daylight time\e|\qcuba standard time\e|\qcvt\e|\qcwst\e|\qcxt\e|\qdavis time\e|\qdavt\e|\qddut\e|\qdumont-durville time\e|\qeasst\e|\qeast\e|\qeast indonesia time\e|\qeaster is. summer time\e|\qeaster is. time\e|\qeastern african time\e|\qeastern daylight time\e|\qeastern european summer time\e|\qeastern european time\e|\qeastern greenland summer time\e|\qeastern greenland time\e|\qeastern standard time\e|\qeastern standard time (new south wales)\e|\qeastern standard time (queensland)\e|\qeastern standard time (tasmania)\e|\qeastern standard time (victoria)\e|\qeastern summer time (new south wales)\e|\qeastern summer time (tasmania)\e|\qeastern summer time (victoria)\e|\qeat\e|\qect\e|\qecuador time\e|\qedt\e|\qeest\e|\qeet\e|\qegst\e|\qegt\e|\qest\e|\qfalkland is. time\e|\qfernando de noronha time\e|\qfet\e|\qfiji summer time\e|\qfiji time\e|\qfjst\e|\qfjt\e|\qfkt\e|\qfnt\e|\qfrench guiana time\e|\qfrench southern & antarctic lands time\e|\qfurther-eastern european time\e|\qgalapagos time\e|\qgalt\e|\qgambier time\e|\qgamt\e|\qgeorgia time\e|\qget\e|\qgft\e|\qghana mean time\e|\qgilbert is. time\e|\qgilt\e|\qgmt\e|\qgreenwich mean time\e|\qgst\e|\qgulf standard time\e|\qguyana time\e|\qgyt\e|\qhadt\e|\qhast\e|\qhawaii standard time\e|\qhawaii-aleutian daylight time\e|\qhawaii-aleutian standard time\e|\qhkt\e|\qhong kong time\e|\qhovd time\e|\qhovt\e|\qhst\e|\qict\e|\qidt\e|\qindia standard time\e|\qindian ocean territory time\e|\qindochina time\e|\qiot\e|\qiran daylight time\e|\qiran standard time\e|\qirdt\e|\qirish summer time\e|\qirkt\e|\qirkutsk time\e|\qirst\e|\qisrael daylight time\e|\qisrael standard time\e|\qist\e|\qjapan standard time\e|\qjst\e|\qkgt\e|\qkhandyga time\e|\qkirgizstan time\e|\qkorea standard time\e|\qkosrae time\e|\qkost\e|\qkrasnoyarsk time\e|\qkrat\e|\qkst\e|\qlhst\e|\qline is. time\e|\qlint\e|\qlord howe standard time\e|\qlord howe summer time\e|\qmacquarie island time\e|\qmagadan time\e|\qmagt\e|\qmalaysia time\e|\qmaldives time\e|\qmarquesas time\e|\qmarshall islands time\e|\qmart\e|\qmauritius time\e|\qmawson time\e|\qmawt\e|\qmdt\e|\qmest\e|\qmet\e|\qmetlakatla standard time\e|\qmht\e|\qmiddle europe summer time\e|\qmiddle europe time\e|\qmist\e|\qmmt\e|\qmoscow standard time\e|\qmountain daylight time\e|\qmountain standard time\e|\qmsk\e|\qmst\e|\qmut\e|\qmvt\e|\qmyanmar time\e|\qmyt\e|\qnauru time\e|\qnct\e|\qndt\e|\qnepal time\e|\qnew caledonia time\e|\qnew zealand daylight time\e|\qnew zealand standard time\e|\qnewfoundland daylight time\e|\qnewfoundland standard time\e|\qnft\e|\qniue time\e|\qnorfolk time\e|\qnovosibirsk time\e|\qnovt\e|\qnpt\e|\qnrt\e|\qnst\e|\qnut\e|\qnzdt\e|\qnzst\e|\qomsk time\e|\qomst\e|\qoral time\e|\qorat\e|\qpacific daylight time\e|\qpacific standard time\e|\qpakistan time\e|\qpalau time\e|\qpapua new guinea time\e|\qparaguay summer time\e|\qparaguay time\e|\qpdt\e|\qperu time\e|\qpet\e|\qpetropavlovsk-kamchatski time\e|\qpett\e|\qpgt\e|\qphilippines time\e|\qphoenix is. time\e|\qphot\e|\qpht\e|\qpierre & miquelon daylight time\e|\qpierre & miquelon standard time\e|\qpitcairn standard time\e|\qpkt\e|\qpmdt\e|\qpmst\e|\qpohnpei time\e|\qpont\e|\qpst\e|\qpwt\e|\qpyst\e|\qpyt\e|\qqyzt\e|\qqyzylorda time\e|\qret\e|\qreunion time\e|\qrothera time\e|\qrott\e|\qsakhalin time\e|\qsakt\e|\qsamara time\e|\qsamoa standard time\e|\qsamt\e|\qsast\e|\qsbt\e|\qsct\e|\qseychelles time\e|\qsgt\e|\qsingapore time\e|\qsolomon is. time\e|\qsouth africa standard time\e|\qsouth georgia standard time\e|\qsrt\e|\qsst\e|\qsuriname time\e|\qsyot\e|\qsyowa time\e|\qtahiti time\e|\qtaht\e|\qtajikistan time\e|\qtft\e|\qtimor-leste time\e|\qtjt\e|\qtkt\e|\qtlt\e|\qtmt\e|\qtokelau time\e|\qtonga time\e|\qtot\e|\qturkmenistan time\e|\qtuvalu time\e|\qtvt\e|\qulaanbaatar time\e|\qulat\e|\quruguay summer time\e|\quruguay time\e|\qust-nera time\e|\qutc\e|\quyst\e|\quyt\e|\quzbekistan time\e|\quzt\e|\qvanuatu time\e|\qvenezuela time\e|\qvet\e|\qvladivostok time\e|\qvlat\e|\qvolgograd time\e|\qvolt\e|\qvost\e|\qvostok time\e|\qvut\e|\qwake time\e|\qwakt\e|\qwallis & futuna time\e|\qwast\e|\qwat\e|\qwest\e|\qwest indonesia time\e|\qwest samoa daylight time\e|\qwest samoa time\e|\qwestern african summer time\e|\qwestern african time\e|\qwestern european summer time\e|\qwestern european time\e|\qwestern greenland summer time\e|\qwestern greenland time\e|\qwestern standard time (australia)\e|\qwet\e|\qwft\e|\qwgst\e|\qwgt\e|\qwib\e|\qwit\e|\qwita\e|\qwsdt\e|\qwst\e|\qyakt\e|\qyakutsk time\e|\qyekaterinburg time\e|\qyekt\e)\q \e(\p{nd}++) at org.apache.commons.lang3.time.fastdateparser.parse(fastdateparser.java:289) at org.apache.commons.lang3.time.fastdateformat.parse(fastdateformat.java:487) "
96,96,"2 0.25489110372831303, 1 0.1786637135474345, 0 0.17607973421926912, 3 0.12956810631229235, 4 0.09468438538205977, 5 0.08305647840531563, 6 0.08305647840531563","i think there is typo in below line:{code:title= org.apache.commons.lang3.math.numberutils.java|borderstyle=solid} if (str.startswith(""0x"", pos) || str.startswith(""0x"", pos)) { // hex radix = 16; pos += 2;}{code}the second ""0x"" should be ""0x""{code:title= org.apache.commons.lang3.math.numberutils.java|borderstyle=solid} if (str.startswith(""0x"", pos) || str.startswith(""0x"", pos)) { // hex radix = 16; pos += 2;}{code} "
97,97,"4 0.21697494424767155, 2 0.1875901875901876, 0 0.16187852551488915, 6 0.15545060999606458, 1 0.14351305260396172, 3 0.0755608028335301, 5 0.05903187721369541","{code:title=org.apache.commons.lang3.arrayutils.java|borderstyle=solid} public static <t> t[] add(final t[] array, final t element) { class<?> type; if (array != null){ type = array.getclass(); } else if (element != null) { type = element.getclass(); } else { throw new illegalargumentexception(""arguments cannot both be null""); } ....... }{code}i think it should be:{code:title=org.apache.commons.lang3.arrayutils.java|borderstyle=solid} public static <t> t[] add(final t[] array, final t element) { class<?> type; if (array != null){ type = array.getclass().getcomponenttype(); } else if (element != null) { type = element.getclass(); } else { throw new illegalargumentexception(""arguments cannot both be null""); } ....... }{code} "
98,98,"0 0.4113402936932348, 1 0.13504795857737037, 2 0.12910618792971737, 3 0.11365758424581955, 5 0.08810797046091165, 6 0.06968848145318733, 4 0.05305152363975893","{code:title= org.apache.commons.lang3.stringutils.java|borderstyle=solid} int found = 0; int index = lastindex ? str.length() : index_not_found; do { if (lastindex) { index = charsequenceutils.lastindexof(str, searchstr, index - 1); } else { index = charsequenceutils.indexof(str, searchstr, index + 1); } if (index < 0) { return index; } found++; } while (found < ordinal);{code}should it be:{code:title= org.apache.commons.lang3.stringutils.java|borderstyle=solid} private static int ordinalindexof(final charsequence str, final charsequence searchstr, final int ordinal, final boolean lastindex) { // if (str == null || searchstr == null || ordinal <= 0) { // return index_not_found; // } // if (searchstr.length() == 0) { // return lastindex ? str.length() : 0; // } // int found = 0; // int index = lastindex ? str.length() : index_not_found; // do { // if (lastindex) { // index = charsequenceutils.lastindexof(str, searchstr, index - 1); // } else { // index = charsequenceutils.indexof(str, searchstr, index + 1); // } // if (index < 0) { // return index; // } // found++; // } while (found < ordinal); // return index; if (str == null || searchstr == null || ordinal <= 0) { return index_not_found; } if (searchstr.length() == 0) { return lastindex ? str.length() : 0; } final int searchstrlen = searchstr.length(); int index = lastindex ? str.length() : 0; for (int found = 0; index >= 0;) { if (lastindex) { index = charsequenceutils.lastindexof(str, searchstr, index); } else { index = charsequenceutils.indexof(str, searchstr, index); } if (index < 0) { return index_not_found; } if (++found >= ordinal) { break; } index = lastindex ? index - searchstrlen : index + searchstrlen; } return index; }{code} "
99,99,"0 0.210189452124936, 6 0.14746543778801843, 2 0.1349206349206349, 3 0.1313364055299539, 5 0.1313364055299539, 4 0.1295442908346134, 1 0.11520737327188944","this is probably just a quirk of the old jdk that was used.the casts are not necessary on other computers, but they don\t seem to hurt either. (please verify that of course!) "
100,100,"5 0.17484737484737484, 3 0.16800976800976802, 0 0.15775335775335775, 4 0.14236874236874236, 6 0.13724053724053722, 1 0.10989010989010992, 2 0.10989010989010992","{{numberutils.createnumber(""-0.0"")}} returns {{bigdecimal}} with 0 signum.caused by the implementation not checking for sign when extracting mantissa from the input string.expected is that negative {{float}} is returned. "
101,101,"0 0.19530710835058662, 3 0.19369680239245457, 2 0.1631009891879457, 1 0.12928456406717276, 6 0.1083505866114562, 4 0.10674028065332415, 5 0.10351966873706007",fastdateparser does not do any validation of dates/times.it acts similarly to simpledateformat (sdf) in lenient mode.however it does not generate the same output as sdf for input where the number of hours is greater than the normal range (e.g. > 12 for hh or > 23 for hh) 
102,102,"0 0.2194805194805195, 5 0.1821067821067821, 4 0.16493506493506493, 2 0.1255411255411255, 6 0.12049062049062047, 3 0.11139971139971139, 1 0.07604617604617601","there is a bug in typeutils.equals(wilcardtype, type). it returns true if the other type is not a wildcardtype, it should return false. see typeutils@1629 for v3.3.2 and typeutils@791 for v3.4bug can be seen with the following test:{code}@test public void shouldhandleequalityofparameterizedtypeswithwildcards() throws exception { // given: class sometype { collection<?> field; } final parameterizedtype wildcardcollectiontype = (parameterizedtype) sometype.class.getdeclaredfield(""field"").getgenerictype(); final wildcardtype wildcard = (wildcardtype) wildcardcollectiontype.getactualtypearguments()[0]; final parameterizedtype ptwithwildcard = typeutils.parameterize(collection.class, wildcard); final parameterizedtype otherpt = typeutils.parameterize(collection.class, string.class); // then: assertthat(otherpt, is(not(equalto(ptwithwildcard)))); // passes assertthat(ptwithwildcard, is(not(equalto(otherpt)))); // fails }{code} "
103,103,"1 0.2753456221198157, 2 0.19380440348182282, 0 0.16423451100870454, 5 0.10867895545314898, 4 0.10778289810547872, 6 0.07642089093701994, 3 0.07373271889400919","unit test for testlang530 fails when the isodatestr comes out with just a z instead of +00:00.{code}tests run: 38, failures: 0, errors: 1, skipped: 0, time elapsed: 0.014 sec <<< failure! - in org.apache.commons.lang3.time.dateutilstesttestlang530(org.apache.commons.lang3.time.dateutilstest) time elapsed: 0.005 sec <<< error!java.text.parseexception: unable to parse the date: 2015-04-17t18:51:52z at org.apache.commons.lang3.time.dateutils.parsedatewithleniency(dateutils.java:401) at org.apache.commons.lang3.time.dateutils.parsedate(dateutils.java:301) at org.apache.commons.lang3.time.dateutils.parsedate(dateutils.java:278) at org.apache.commons.lang3.time.dateutilstest.testlang530(dateutilstest.java:1222){code}on a linux machine where this test passes, isodatestr is 2015-04-17t19:26:03+00:00. "
104,104,"4 0.18708994708994708, 2 0.1619047619047619, 1 0.14857142857142858, 3 0.14857142857142858, 0 0.13523809523809524, 6 0.11005291005291004, 5 0.10857142857142857","unlike what is said in javadoc comment, when passing a negative repeat value to the *stringutils.repeat(char, int)* function, it doesnt return an empty string but throws a _negativearraysizeexception_.see pr #72 : https://github.com/apache/commons-lang/pull/72 "
105,105,"1 0.18764948901935205, 4 0.16634050880626225, 0 0.14046531854751032, 3 0.13894324853228962, 6 0.13742117851706892, 2 0.11763426831919983, 5 0.11154598825831703","{code}import org.apache.commons.lang3.stringutils;public class main { public static void main(string[] args) { system.out.println(stringutils.stripaccents(""ÄÅÃÅÅ»Å¹ÄÅ ÄÅÃ³ÅÅ¼ÅºÄÅ"")); }}{code} "
106,106,"4 0.2281545614878948, 1 0.1922398589065256, 2 0.16418149751483083, 3 0.13836780503447169, 6 0.10245310245310243, 0 0.0945967612634279, 5 0.08000641333974666",following the discussion at https://github.com/apache/commons-lang/pull/47 we need to decide how malformed inputs should be handled by the swap method. we have to handle several forms of malformed inputs and we should decide how to do that based on the current behavior of arrayutils. malformed inputs are:# array == null# array.length == 0# offset1 < 0# offset2 < 0# len < 0# offset1 > offset2# offset1 > array.length# offset2 > array.length# offset1 + len > array.length# offset2 + len > array.length 
107,107,"4 0.2187153931339978, 3 0.20191952750092285, 0 0.14119601328903653, 2 0.13344407530454042, 1 0.12310815799187891, 6 0.09726836471022515, 5 0.08434846806939832","placeholder for https://github.com/apache/commons-lang/pull/74{quote}except number, boolean, array and nested object structures, other types like char, string, date etc. in java should be appendasstring.add method {{appenddetail(stringbuffer buffer, string fieldname, char value) to jsontostringstyle}}modify {{appenddetail(stringbuffer buffer, string fieldname, object value)}}{quote} "
108,108,"3 0.20820449391877968, 2 0.14471243042671614, 4 0.1432694289837147, 0 0.14182642754071326, 5 0.13172541743970315, 6 0.12306740878169449, 1 0.10719439290867862",the following test will fail because the {{equals(strbuilder)}} overload in {{strbuilder}} does not check for null inputs:{code:java} @test public void testequalswithnullstrbuilder() throws exception { final strbuilder sb = new strbuilder(); final strbuilder other = null; assertfalse(sb.equals(other)); }{code} 
109,109,"1 0.2657329598506069, 2 0.15331465919701212, 4 0.1415499533146592, 0 0.12324929971988793, 3 0.12063492063492061, 6 0.10756302521008401, 5 0.08795518207282915","placeholder for https://github.com/apache/commons-lang/pull/85{quote}as described in its [javadoc|http://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/builder/reflectiontostringbuilder.html#reflectiontostringbuilder(java.lang.object)], reflectiontostringbuilder constructor will throw illegalargumentexception if the object to build a tostringfor is null, while in fact it wont.{quote} "
110,110,"2 0.18602400309717385, 1 0.18466898954703834, 0 0.1670538133952768, 6 0.13317847464188926, 4 0.12233836624080525, 3 0.11420828493999224, 5 0.09252806813782426",fastdateparser_timezonestrategytest#testtimezonestrategypattern() on current master fails:{quote}java.lang.assertionerror: franzÃ¶sisch:heure deurope de lest utc+3 at org.junit.assert.fail(assert.java:88) at org.junit.assert.asserttrue(assert.java:41) at org.apache.commons.lang3.time.fastdateparser_timezonestrategytest.testtimezonestrategypattern(fastdateparser_timezonestrategytest.java:39){quote}im unsure why. i guess it has something to do with my german locale and maybe windows too. 
111,111,"4 0.21937705899970053, 2 0.2078466606768494, 3 0.16172506738544476, 0 0.11665169212339023, 5 0.11455525606469001, 6 0.10302485774183887, 1 0.07681940700808625","the capitalize javadoc says the code uses character#totitlecase, however the code actually uses character#touppercase.generally these produce the same result, but some charsets may have different characters for upper and title case - see for example the javadoc [1] for character#istitlecase.the way i read this, the character that looks like ""lj"" is lower-case, ""lj"" is upper case and ""lj"" is title case - i.e. not the same.the question here is: should the code be corrected to use titlecase or should the javadoc be corrected to use uppercase?[1] http://docs.oracle.com/javase/7/docs/api/java/lang/character.html#istitlecase%28char%29 "
112,112,"2 0.1819879466938291, 3 0.17485782191664548, 1 0.14277226041931926, 6 0.13861302096596215, 0 0.13504795857737034, 4 0.12970036499448265, 5 0.09702062643239114","it is possible to create a construct, that allows multiple calls of lazyinitializer.initialize, when calculations (which can be very expensive) return null as result. in the javadoc is described that the initialize method will be called only on the first access{code:java} /** * creates and initializes the object managed by this {@code * lazyinitializer}. this method is called by {@link #get()} when the object * is accessed for the first time. an implementation can focus on the * creation of the object. no synchronization is needed, as this is already * handled by {@code get()}. * * @return the managed data object * @throws concurrentexception if an error occurs during object creation */ protected abstract t initialize() throws concurrentexception;{code}the junit test can be something like this:*(fix can be appplied from attached patch-file)*{code:java}package edu.test;import static org.junit.assert.assertequals;import org.apache.commons.lang3.concurrent.concurrentexception;import org.apache.commons.lang3.concurrent.lazyinitializer;import org.junit.test;public class lazyinitializertest { private int lazyinitcounter = 0; private lazyinitializer<object> lazyiinit = new lazyinitializer<object>() { @override protected object initialize() throws concurrentexception { lazyinitcounter++; return dosomeveryexpensiveoperations(); } }; private object dosomeveryexpensiveoperations() { // do db calls // do some complex math calculations // the result of them all is null return null; } @test public void testinitialization() throws exception { lazyiinit.get(); lazyiinit.get(); assertequals(""multiple call of lazyinitializer#initialize"", 1, lazyinitcounter); }}{code} "
113,113,"2 0.24801587301587302, 4 0.17625661375661375, 0 0.17278439153439154, 1 0.11954365079365077, 3 0.10796957671957672, 6 0.10102513227513225, 5 0.07440476190476192","in *enumutils* all _bitvector_ related methods fail in handling enums with more than 32 values.this is due to a implicit _int_ -> _long_ conversion in generating the enum value _long_ mask.*bad code :* here *1* is an _int_ value so the *<<* operation is done into an _int_ context and then, the result is converted to a _long_ value{code}long mask = 1 << 32; // -> mask = 1 and not 4294967296 (0x100000000){code}*good code :* here *1l* is a _long_ value so the *<<* operation is done into an _long_ context{code}long mask = 1l << 32; // -> mask = 4294967296 (0x100000000){code}see pr#97 : https://github.com/apache/commons-lang/pull/97 "
114,114,"0 0.19122315592903827, 2 0.18730158730158733, 3 0.16638655462184873, 4 0.15592903828197946, 1 0.11671335200746963, 6 0.09710550887021473, 5 0.08534080298786183","from the commons user mailing list:{quote}stringutils.equals(cs1,cs2) delegates to charsequence.regionmatches(...) in a way that causes indexoutofbounds when either of cs1/cs2 isnt a string.specifically, comparing ""foo"" and ""foobar"" for non-string charsequences bombs due to charsequenceutils.regionmatches(cs1, false, 0, cs2, 0, math.max(cs1.length(), cs2.length())) because regionmatches doesnt check for input exhaustion.{quote} "
115,115,"0 0.21924603174603174, 3 0.14285714285714285, 5 0.14112103174603174, 1 0.12896825396825395, 2 0.12723214285714285, 4 0.12549603174603174, 6 0.1150793650793651",there are no tests for charsequenceutils.regionmatches.it ought to behave the same way as the string version.this includes not failing with index oobe if the charsequences are not long enough. 
116,116,"3 0.19246031746031741, 0 0.1878306878306878, 4 0.185515873015873, 2 0.15889550264550262, 6 0.1264880952380952, 1 0.07440476190476189, 5 0.07440476190476189","the method arrayutils.removeall(object array, int... indices) currently sorts the input indices array. therefore the array needs to be cloned; this is currently done by the callers.however the sort is an implementation detail of the method, so should be done by the method itself, not by the callers, which is fragile (easy to overlook when creating a new method) and unnecessary.this would also allow the method to be more easily changed to a different implementation that does not need to sort the array (e.g. using bitset) "
117,117,"4 0.2124358515335959, 0 0.16565222580260175, 1 0.14309583482515814, 3 0.12972908461630267, 5 0.12972908461630267, 6 0.12722281895214227, 2 0.09213509965389664","{code:java}import static org.apache.commons.lang3.reflect.typeutils.*;import java.lang.reflect.invocationtargetexception;import java.lang.reflect.type;import java.util.arraylist;public class demonstration { public static <u> iterable<u> somemethod() { return null; } public static class workingclass extends arraylist { } public static class failingclass extends arraylist<object> { } public static void main(string[] args) throws nosuchmethodexception, securityexception, illegalaccessexception, illegalargumentexception, invocationtargetexception { type fromtype = demonstration.class.getdeclaredmethod(""somemethod"").getgenericreturntype(); type workingtotype = wildcardtype().withlowerbounds(workingclass.class).build(); type failingtotype = wildcardtype().withlowerbounds(failingclass.class).build(); system.out.println(fromtype); system.out.println(workingtotype); system.out.println(failingtotype); system.out.println(isassignable(fromtype, workingtotype)); system.out.println(isassignable(fromtype, failingtotype)); }}{code} "
118,118,"1 0.2527539248850725, 0 0.1829300026021338, 2 0.17200104085349988, 3 0.1228207129846474, 6 0.09792696677942579, 4 0.0936768149882904, 5 0.07789053690693035","the java simpledateformat supports two year-components, y for normal year and y for week year, see http://docs.oracle.com/javase/7/docs/api/java/text/simpledateformat.htmlhowever when we try to use fastdateformat to parse a format which uses the week-year, it fails with an exception{noformat}java.lang.illegalargumentexception: illegal pattern component: yyyy at org.apache.commons.lang3.time.fastdateprinter.parsepattern(fastdateprinter.java:282) at org.apache.commons.lang3.time.fastdateprinter.init(fastdateprinter.java:149) at org.apache.commons.lang3.time.fastdateprinter.<init>(fastdateprinter.java:142) at org.apache.commons.lang3.time.fastdateformat.<init>(fastdateformat.java:384) at org.apache.commons.lang3.time.fastdateformat.<init>(fastdateformat.java:369) at org.apache.commons.lang3.time.fastdateformat$1.createinstance(fastdateformat.java:91) at org.apache.commons.lang3.time.fastdateformat$1.createinstance(fastdateformat.java:88) at org.apache.commons.lang3.time.formatcache.getinstance(formatcache.java:82) at org.apache.commons.lang3.time.fastdateformat.getinstance(fastdateformat.java:119){noformat}simple unit test to reproduce this:{code} @test public void testcommonslang() { date date = new date(); format dateformat = new simpledateformat(""yyyy""); assertnotnull(dateformat.format(date)); dateformat = fastdateformat.getinstance(""yyyy""); assertnotnull(dateformat.format(date)); }{code} "
119,119,"0 0.25215993570423956, 1 0.16636528028933092, 4 0.13964235483222823, 2 0.12979706650592726, 5 0.11573236889692584, 3 0.10588708057062486, 6 0.09041591320072336","in apache commons lang 3.4, stringutils.ordinalindexof(""abc"", ""ab"", 1) gives incorrect answer of -1 (correct answer should be 0)ãbut stringutils.ordinalindexof(""abc"", ""a"", 1) gives correct answer of 0.based on the above mentioned observation, the bug occurrs if the searchstr is of length > 1, and locates at the index 0 of the str.in apache commons lang 2.6, this bug is not observed. "
120,120,"4 0.2225495009000164, 2 0.17443953526427758, 1 0.16069383079692362, 0 0.1309114711176567, 3 0.12747504500081822, 6 0.09883816069383079, 5 0.08509245622647685","the current implementation of stringutils.getjarowinklerdistance() does not compute the correct result in some cases. see #lang-944 for the initial code contribution.stringutils.getjarowinklerdistance(""haus ingeborg"", ""ingeborg esser"") == 0.0this is due to the incorrect computation of common characters, which causes the algorithm to exit prematurely.in contrast, the implementation in lucene gives ~0.63, which is about right. jarowinklerdistance d = new jarowinklerdistance(); getdistance(""haus ingeborg"", ""ingeborg esser"");see https://lucene.apache.org/core/3_0_3/api/contrib-spellchecker/org/apache/lucene/search/spell/jarowinklerdistance.html "
121,121,"2 0.15571975916803507, 1 0.1423097974822113, 0 0.14039408866995076, 3 0.14039408866995076, 4 0.14039408866995076, 5 0.14039408866995076, 6 0.14039408866995076","lang-799 added support for specifying a locale, but parsedatestrictly() doesn\t pass it to the final parsedatewithleniency() method. "
122,122,"4 0.17518389469608983, 0 0.1616337591947348, 3 0.1480836236933798, 6 0.14401858304297327, 5 0.13724351529229578, 2 0.12098335269066975, 1 0.11285327138985675","the {{numberutils.createnumber()}} method fails to check for multiple trailing characters, and as a result, it returns a value even though {{numberutils.isnumber()}} indicates that it should not. for example:{code}boolean isnumber = numberutils.isnumber(""81.5514dd""); // returns falsenumber numvalue = numberutils.createnumber(""81.5514dd""); // returns a double value, 81.5514{code}i would expect the {{createnumber()}} method to throw a {{numberformatexception}} in this case. "
123,123,"4 0.20398217766638818, 1 0.19423558897243107, 6 0.170843776106934, 2 0.11626287942077412, 3 0.113338902812587, 0 0.11041492620439987, 5 0.09092174881648564","classutils.getclass(classutils.class.getclassloader(), ""void"") throws ""classnotfoundexception: [v"".root cause: classutils contains an abbreviationmap for use in dealing with abbreviated primitive types like ""[i"" and ""[j"". however, [this commit|https://git-wip-us.apache.org/repos/asf?p=commons-lang.git;a=blobdiff;f=src/main/java/org/apache/commons/lang3/classutils.java;h=c15636ed99af1913d8436a2761d2e3e45b0c8b1a;hp=2492182dd6a383bbec970be3c58799bf89929ccf;hb=1d6ab5b8c0bcc69fe5984b882374e856ec198d0e;hpb=609319df2216e00d8f158e5fc5ce7756134b7cb0] introduces a ""void -> v"" mapping for ""completeness"".this seems wholly erroneous, since the maps are used only for [primitive array abbreviations|http://docs.oracle.com/javase/6/docs/api/java/lang/class.html#getname%28%29], and ""void/v"" is not among them. "
124,124,"0 0.3490529867341461, 2 0.18372824169925625, 3 0.1279043018173453, 6 0.12575722720650256, 5 0.0865731155586228, 4 0.08335250364235872, 1 0.04363162334176826","fastdateformat cant properly parse dates with daylight saving in the ""z"" pattern. it always returns date without daylight saving. test case:{code:java} simpledateformat format = new simpledateformat(""dd.mm.yyyy hh:mm:ss z"", locale.germany); date d1 = format.parse(""26.10.2014 02:00:00 mesz""); date d2 = format.parse(""26.10.2014 02:00:00 mez""); system.out.println(d1); system.out.println(d2); fastdateformat formatt = fastdateformat.getinstance(""dd.mm.yyyy hh:mm:ss z"", locale.germany); date d3 = formatt.parse(""26.10.2014 02:00:00 mesz""); date d4 = formatt.parse(""26.10.2014 02:00:00 mez""); system.out.println(d3); system.out.println(d4); {code}returns:sdf: sun oct 26 02:00:00 cest 2014sdf: sun oct 26 02:00:00 cet 2014fdf: sun oct 26 02:00:00 cet 2014fdf: sun oct 26 02:00:00 cet 2014fastdateformat returns the same date, which is wrong.bug is in the fastdateparser.timezonestrategy.setcalendar:{code:java}@override void setcalendar(final fastdateparser parser, final calendar cal, final string value) { timezone tz; if(value.charat(0)==+ || value.charat(0)==-) { tz= timezone.gettimezone(""gmt""+value); } else if(value.startswith(""gmt"")) { tz= timezone.gettimezone(value); } else { tz= tznames.get(value); if(tz==null) { throw new illegalargumentexception(value + "" is not a supported timezone name""); } } cal.settimezone(tz); }{code}its not enough to just call: cal.settimezone.if zone names in standard and daylight time are different, you have to check the name in dateformatsymbols.getinstance(locale).getzonestrings(); and if its >= 3, you have to activate daylight mode.just like simpledateformat does it:{code:java}1491 // (abbreviation) for both standard and daylight time,1492 // let the time zone in the calendar decide which one.1493 if (!usesamename) {1494 calendar.set(calendar.zone_offset, tz.getrawoffset());1495 calendar.set(calendar.dst_offset,1496 j >= 3 ? tz.getdstsavings() : 0);1497 }{code} "
125,125,"3 0.20013802622498272, 4 0.16149068322981366, 0 0.14860823556475727, 6 0.14860823556475727, 2 0.13411548194156886, 1 0.10351966873706006, 5 0.10351966873706006","these work with 3.3.2, but fail with 3.4:{code}assertequals(""b"", stringutils.normalizespace(""\u0000b""));assertequals(""b"", stringutils.normalizespace(""b\u0000""));{code}java doc still says ""... additionally #trim(string)} removes control characters (char <= 32) from both ends of this string. "
126,126,"3 0.20679633355689694, 2 0.19740666219539457, 4 0.1629778672032193, 1 0.12933154482450257, 0 0.12541918175720992, 6 0.12072434607645875, 5 0.05734406438631789","we observed a severe performance regression in hashcodebuilder in 3.5 trunk compared to 3.4 release. we get about 20% of the throughput in 3.5 trunk for common cases compared to 3.4 release. previously there was no noticeable overhead of using hashcodebuilder. investigating we found the performance degradation was caused by the fix for lang-456. it causes the method to be too large to be inlined and escape analysis to fail (see lang-1218 for a related discussion).we currently do not see a way to keep the 3.4 performance and support cyclic graphs. the append methods have not supported cycles for so long we feel its de facto part of the contract by now. since neither the jdk nor the guava hashcode helper methods support cyclic graphs we dont believe this is an unreasonable assumption. in addition equalsbuilder#append(object,object) doesnt support cycles.if supporting cycles is a requirement we propose the introduction of new #appendrecursive (or named differently) methods to both hashcodebuilder and equalsbuilder that add cycle guards. if that is an acceptable compromise we would be willing to provide patches. "
127,127,"0 0.2379482657260435, 3 0.19576719576719576, 2 0.15255731922398588, 4 0.14947089947089945, 5 0.08980011757789534, 1 0.0887713109935332, 6 0.08568489124044677","were running into contention issues in registry lookup in equalsbuilder and hashcodebuilder. we believe the synchronization for the registry lookup is unnecessary. threadlocals are thread safe, each thread gets own value. therefore no other thread can read or change the value of the current thread. as a consequence access to threadlocals does not need to be synchronized.since idkey uses object identity and the identity hashcode it does use neither equalsbuilder nor hashcodebuilder. this means that recursive calls to register and unregister are not possible even if the registered objects use equalsbuilder or hashcodebuilder. this also makes re-reading redundant.the issue was likely introduced in 2.5 by lang-586 but 2.6 is the oldest version we can select. "
128,128,"3 0.20611229566453448, 1 0.16631130063965885, 4 0.13977730395640842, 2 0.13646055437100213, 6 0.12319355602937693, 0 0.12153518123667377, 5 0.10660980810234545","the other append methods throw an illegalargumentexception if fieldname is null. so, append(object) and append(object[]) should also do this.source: [https://github.com/apache/commons-lang/pull/121] "
129,129,"3 0.18509550712940545, 1 0.1606133979015335, 4 0.14178100618778586, 2 0.1361312886736616, 6 0.1342480495022868, 0 0.12106537530266348, 5 0.12106537530266348","add back method java.lang.stringbuffer applyrules(java.util.calendar, java.lang.stringbuffer) "
130,130,"0 0.17910767910767914, 1 0.15358215358215357, 2 0.15358215358215357, 4 0.15358215358215357, 3 0.13406263406263405, 6 0.11604461604461609, 5 0.11003861003861004",when the code was migrated from stringbuffer to appendable in lang-1152.weve lost the ability to modify the buffer (setcharat) the new implementation of appendfulldigits allocate a temporary char array to work around that limitation.this is a major source of memory allocation which is not present in version 3.4. 
131,131,"1 0.1841269841269841, 0 0.17523809523809522, 4 0.13968253968253969, 3 0.13375661375661374, 6 0.13375661375661374, 2 0.1219047619047619, 5 0.11153439153439153","in considering the issues lang-1060, lang-1040, lang-1038, and lang-992, it seems that there are times when {{numberutils.isnumber}} resolves to {{false}} while {{numberutils.createnumber}}, given the same input, does not throw an exception, returning a valid {{java.lang.number}}. this inconsistency should be resolved either by making {{isnumber}} more lenient or {{createnumber}} more stringent. "
132,132,"4 0.26609595148920995, 3 0.16497235598359192, 6 0.15186374175138218, 0 0.14811842339932224, 2 0.12377385411093274, 5 0.08819332976636345, 1 0.05698234349919741","arrayutils.contains(object[] array, object objecttofind) wrongly returns false.steps to reproduce=========================================================-create a superclass ""parent"" and override equals and hashcode based on some member id variable.-create a class ""child"" extending ""parent"". do not override equals nor hashcode.-let ""childrens"" be an array of type child[] containing several instances.create an instance of parent ""p"" with the same id as childrens[0], such that childrens[0].equals(p) returns true and p.equals(childrens[0]) returns true as well.because they are equals, arrayutils.contains(childrens, p) should return true. however it returns false.where the bug is located=====================================================-go to arrayutils.class, line 1917. in the ""indexof"" method implementation, before going into calling equals for each element of the input array, there is some sort of optimization check to make sure the instance to be found is an instance of the array type:} else if (array.getclass().getcomponenttype().isinstance(objecttofind)) {that line is wrong. in our case, the array contains elements of type ""child"", whereas the object to be found is of type ""parent"". they are equals according to the equals implementation of ""parent"", but obviously children.class.isinstance(p) is false.expected behavior================================================since the method signature accepts an array of object[] and an instance of object, it should ignore the classes of the arguments. it should be possible to call ""arrayutils.contains(child[] children, parent p)"", in fact it should be possible to do this with any combination of classes, not only the ones assignable from the class hierarchy. "
133,133,"4 0.2054043839758126, 3 0.19217687074829937, 0 0.14455782312925172, 2 0.1207482993197279, 6 0.11810279667422525, 5 0.11016628873771732, 1 0.108843537414966","issue is the same as in lang-1218: comparetobuilder.append(object,object,comparator) is quite big, due to in-place arrays processing, and thus breaching inlining threshold (325 bytecodes):{noformat}....o.a.c.l.b.comparetobuilder::append (346 bytes) hot method too big....{noformat}this prevents comparetobuilder object itself from being scalarized.fix may be the same, as in lang-1218: extract arrays processing into separate method. "
134,134,"3 0.21038961038961043, 0 0.20028860028860032, 4 0.13463203463203466, 2 0.1295815295815296, 6 0.1295815295815296, 5 0.1113997113997114, 1 0.08412698412698412","the name of the method stringutils::getjarowinklerdistance is misleading.currently for equal strings {{1}} is returned, for completely different strings {{0}} is returned. that is a measure of similarity, not of a distance. a distance must be {{0}} for equal strings. i read on the issues lang-591 and lang-944, that it was decided to have a similar name to stringutils::getlevenshteindistance, but that requires also the change of the methods result.could you please (1) rename the method to stringutils::getjarowinklersimilarity or (2) change the method to return {{1 - currentresult}}?first option has the disadvantage to lose the similar naming of the similar methods, second option implies the risk to unnoticed introduce bugs in depending code. so i think it is preferable to use the first option. "
135,135,"0 0.16359447004608296, 2 0.16359447004608296, 4 0.14746543778801843, 5 0.14746543778801843, 3 0.13133640552995393, 6 0.13133640552995393, 1 0.11520737327188946","an empty array does not contain any empty/blank charsequences, so isanyempty/isanyblank should return false for an empty array. "
136,136,"1 0.3058730158730159, 3 0.1580952380952381, 4 0.1580952380952381, 2 0.11031746031746029, 0 0.10698412698412697, 6 0.08920634920634918, 5 0.07142857142857144","there is a bug in replace for strbuilder, seems the use of nonupdated buffer and character count is off.new strbuilder(""dear x, hello x."").replaceall(strmatcher.stringmatcher(""x""), ""012345678901234567"");yields{noformat}java.lang.arrayindexoutofboundsexception: 49 at org.apache.commons.lang3.text.strmatcher$stringmatcher.ismatch(strmatcher.java:372) at org.apache.commons.lang3.text.strbuilder.replaceimpl(strbuilder.java:2115) at org.apache.commons.lang3.text.strbuilder.replace(strbuilder.java:2088) at org.apache.commons.lang3.text.strbuilder.replaceall(strbuilder.java:2049){noformat} "
137,137,"1 0.42337840485988637, 2 0.15931804820693712, 3 0.12845385067607293, 6 0.09484616892024302, 0 0.08524397413286303, 5 0.055751518714481675, 4 0.05300803448951598","it seems that after lang-1186 was fixed, and before 3.5 went out, the bug was re-introduced.one of my customers is getting the following error (i am actually not able to reproduce it) with 3.5:{code}java.lang.nullpointerexception at org.apache.commons.lang3.time.fastdateparser$timezonestrategy.<init>(fastdateparser.java:869) at org.apache.commons.lang3.time.fastdateparser.getlocalespecificstrategy(fastdateparser.java:637) at org.apache.commons.lang3.time.fastdateparser.getstrategy(fastdateparser.java:606) at org.apache.commons.lang3.time.fastdateparser.access$100(fastdateparser.java:73) at org.apache.commons.lang3.time.fastdateparser$strategyparser.letterpattern(fastdateparser.java:234) at org.apache.commons.lang3.time.fastdateparser$strategyparser.getnextstrategy(fastdateparser.java:220) at org.apache.commons.lang3.time.fastdateparser.init(fastdateparser.java:167) at org.apache.commons.lang3.time.fastdateparser.<init>(fastdateparser.java:153) at org.apache.commons.lang3.time.fastdateformat.<init>(fastdateformat.java:394) at org.apache.commons.lang3.time.fastdateformat.<init>(fastdateformat.java:378) at org.apache.commons.lang3.time.fastdateformat$1.createinstance(fastdateformat.java:100) at org.apache.commons.lang3.time.fastdateformat$1.createinstance(fastdateformat.java:97) at org.apache.commons.lang3.time.formatcache.getinstance(formatcache.java:81) at org.apache.commons.lang3.time.fastdateformat.getinstance(fastdateformat.java:128){code} "
138,138,"3 0.20382076134288524, 0 0.19497120382076133, 4 0.15170670037926673, 2 0.14285714285714285, 6 0.13499086950414385, 5 0.10745891276864726, 1 0.0641944093271527","{{randomstringutils.random()}} can overflow and return characters that are outside the range specified by the {{start}} and {{end}} parameters. this is because it casts a random integer in the range {{[start,end)}} to a character, without checking if this will overflow.example failing test case:{code}@testpublic void testcharoverflow() throws exception { int start = 65535; int end = integer.max_value; @suppresswarnings(""serial"") random fixedrandom = new random() { @override public int nextint(int n) { // prevents selection of start as the character return 1; } }; string result = randomstringutils.random(1, start, end, false, false, null, fixedrandom); char c = result.charat(0); asserttrue(c >= start && c < end);}{code} "
139,139,"2 0.1645962732919255, 4 0.1645962732919255, 3 0.16338854382332646, 0 0.15251897860593513, 6 0.13440303657694963, 1 0.12111801242236024, 5 0.09937888198757762","{quote}i faced that the random method can cause an infinite loop. it can be caused if the end parameter is too low for generating either numbers (< 48) or letters (<65). i added some exception tests to make the cases clear. basically, if we call the random function with for example numbers = true && end < 48 the validation for character.isdigit(ch) will fail and we increment count count++.{quote}ivan morozov https://github.com/apache/commons-lang/pull/211 "
140,140,"1 0.2813569872393403, 0 0.17351384998443828, 2 0.13538748832866482, 6 0.12994086523498288, 3 0.12013694366635544, 4 0.08745720510426393, 5 0.07220666044195459","running following line of code results in stringindexoutofboundsexception (in 3.5 release){code}wordutils.wrap(""aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"",70);{code}{code}java.lang.stringindexoutofboundsexception: string index out of range: -1 at java.lang.string.substring(string.java:1967) at org.apache.commons.lang3.text.wordutils.wrap(wordutils.java:328) at org.apache.commons.lang3.text.wordutils.wrap(wordutils.java:176) at org.apache.commons.lang3.text.wordutils.wrap(wordutils.java:100) at pl.netpr.commons.string.texttoolstest.testwrap(texttoolstest.java:245) {code}it worked fine with 3.4 releae. "
141,141,"0 0.2343666773196975, 1 0.2231809949930756, 4 0.1747097049110472, 6 0.10535847448599125, 3 0.10162991371045062, 2 0.08746138276339617, 5 0.07329285181634172","since release 3.5 and due to the changes of lang-1115 an arraystoreexception occurs on methodutils.invokemethod if using varargs arguments and smaller types than the method defines (e.g. int vs long).{code} @test public void testmethodutilsinvokemethodvarargs () throws exception { myobject object = new myobject (); methodutils.invokemethod (object, ""dosomething"", 1); } public static class myobject { public void dosomething (long... args) { system.out.println (""dosomething""); } }{code}throws {code}java.lang.arraystoreexception at java.lang.system.arraycopy(native method) at org.apache.commons.lang3.reflect.methodutils.getvarargs(methodutils.java:497) at org.apache.commons.lang3.reflect.methodutils.tovarargs(methodutils.java:463) at org.apache.commons.lang3.reflect.methodutils.invokemethod(methodutils.java:234) at org.apache.commons.lang3.reflect.methodutils.invokemethod(methodutils.java:270) at org.apache.commons.lang3.reflect.methodutils.invokemethod(methodutils.java:147){code}in 3.4. a nosuchmethodexception had been thrown, but in 3.5 the code now finds the matching method but fails then with above exception. "
142,142,"4 0.17612146307798485, 0 0.17225672877846793, 3 0.15969634230503796, 2 0.15486542443064186, 1 0.11235334713595582, 5 0.11235334713595582, 6 0.11235334713595582","typeutils.tostring() doesnt handle primitive and object arrays correctly.specifically, these tests will fail:{code}assertequals(""int[]"", typeutils.tostring(int[].class));assertequals(""java.lang.integer[]"", typeutils.tostring(integer[].class));{code}if you declare a field with type {{list<string>[]}}, then you can add this test:{code}assertequals(""java.util.list<java.lang.string>[]"", typeutils.tostring(field.getgenerictype()));{code}this patch fixes the issue:{code} private static string classtostring(final class<?> c) {// begin patch if (c.isarray()) { return tostring(c.getcomponenttype()) + ""[]""; }// end patch final stringbuilder buf = new stringbuilder();{code} "
143,143,"0 0.20338624338624342, 5 0.17523809523809522, 6 0.1456084656084656, 2 0.14116402116402116, 4 0.13523809523809524, 1 0.10412698412698414, 3 0.09523809523809527","these all work:{code:java}system.out.println(new locale(""en"", ""001""));system.out.println(new locale(""en"", ""150""));system.out.println(new locale(""ar"", ""001""));{code}but these all fail with an illegalargumentexception:{code:java}system.out.println(localeutils.tolocale(""en_001""));system.out.println(localeutils.tolocale(""en_150""));system.out.println(localeutils.tolocale(""ar_001""));{code} "
144,144,"1 0.5006191601936282, 4 0.105032083755488, 0 0.09478779691545647, 2 0.08690757626927838, 5 0.08217944388157153, 3 0.06563098052459754, 6 0.06484295845997973","multilinerecursivetostringstyle style = new multilinerecursivetostringstyle();string result = tostringbuilder.reflectiontostring(new string[] {""1"",""2""}, style);java.lang.stackoverflowerror at org.apache.commons.lang3.builder.tostringstyle.appendstart(tostringstyle.java:409) at org.apache.commons.lang3.builder.tostringbuilder.<init>(tostringbuilder.java:262) at org.apache.commons.lang3.builder.reflectiontostringbuilder.<init>(reflectiontostringbuilder.java:481) at org.apache.commons.lang3.builder.reflectiontostringbuilder.tostring(reflectiontostringbuilder.java:300) at org.apache.commons.lang3.builder.reflectiontostringbuilder.tostring(reflectiontostringbuilder.java:157) at org.apache.commons.lang3.builder.recursivetostringstyle.appenddetail(recursivetostringstyle.java:74) at org.apache.commons.lang3.builder.multilinerecursivetostringstyle.reflectionappendarraydetail(multilinerecursivetostringstyle.java:142) at org.apache.commons.lang3.builder.reflectiontostringbuilder.reflectionappendarray(reflectiontostringbuilder.java:633) at org.apache.commons.lang3.builder.reflectiontostringbuilder.appendfieldsin(reflectiontostringbuilder.java:538) at org.apache.commons.lang3.builder.reflectiontostringbuilder.tostring(reflectiontostringbuilder.java:711) at org.apache.commons.lang3.builder.reflectiontostringbuilder.tostring(reflectiontostringbuilder.java:301) at org.apache.commons.lang3.builder.reflectiontostringbuilder.tostring(reflectiontostringbuilder.java:157) at org.apache.commons.lang3.builder.recursivetostringstyle.appenddetail(recursivetostringstyle.java:74) at org.apache.commons.lang3.builder.multilinerecursivetostringstyle.reflectionappendarraydetail(multilinerecursivetostringstyle.java:142) "
145,145,"1 0.3974266474266475, 0 0.36375661375661383, 2 0.057359307359307374, 6 0.05399230399230401, 4 0.0497835497835498, 3 0.046416546416546425, 5 0.03126503126503127","the following code{code:java}final method method = enum.class.getmethod(""valueof"", class.class, string.class);final string typetext = typeutils.tostring(method.getgenericreturntype());{code}throws the following{code:none}exception in thread ""main"" java.lang.stackoverflowerror at sun.reflect.generics.reflectiveobjects.parameterizedtypeimpl.getrawtype(parameterizedtypeimpl.java:126) at sun.reflect.generics.reflectiveobjects.parameterizedtypeimpl.getrawtype(parameterizedtypeimpl.java:40) at org.apache.commons.lang3.reflect.typeutils.parameterizedtypetostring(typeutils.java:1790) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1666) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.typevariabletostring(typeutils.java:1775) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1672) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.parameterizedtypetostring(typeutils.java:1803) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1666) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.typevariabletostring(typeutils.java:1775) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1672) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.parameterizedtypetostring(typeutils.java:1803) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1666) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.typevariabletostring(typeutils.java:1775) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1672) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.parameterizedtypetostring(typeutils.java:1803) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1666) at org.apache.commons.lang3.reflect.typeutils.appendallto(typeutils.java:1846) at org.apache.commons.lang3.reflect.typeutils.typevariabletostring(typeutils.java:1775) at org.apache.commons.lang3.reflect.typeutils.tostring(typeutils.java:1672)...{code} "
146,146,"1 0.22100122100122105, 0 0.1440781440781441, 3 0.13724053724053722, 5 0.13553113553113552, 4 0.12698412698412698, 6 0.12527472527472527, 2 0.10989010989010993",seehttps://stackoverflow.com/questions/45603317/org-apache-commons-lang3-builder-equalsbuilderandhttps://github.com/apache/commons-lang/pull/282for details. 
147,147,"0 0.2828387393604785, 3 0.19427191166321597, 4 0.15159880377271678, 6 0.11214630779848168, 1 0.09604324821716123, 5 0.08960202438463305, 2 0.0734989648033126","{quote} i have found the design of three root cause related methods inconsistent when the input throwable does not wrap up another throwable. these three methods are 1. getrootcause(throwable t) 2. getrootcausemessage(throwable t) 3. getrootcausestacktrace(throwable t) when the input t has no lower level cause: - the first method returns null; - the second method returns the message of t, which means the input t is considered as the root cause in this method; - the third method returns the stack trace of t, which also means this method considers t as the root cause. therefore, i consider the design of the first method is not consistent with the second and the third. i usually write a function myself to get the root cause of an exception; and it makes much better sense to me the root cause of a throwable is itself if no more lower level cause exists. a request: change the first method to return t itself when there is no more causes. {quote} reported by zheng xie in https://mail-archives.apache.org/mod_mbox/commons-dev/201710.mbox/%3ccal-lhk7jvqgm9j1spxlb2qesxazwwq%2bykuv29xgwxeccchun0w%40mail.gmail.com%3e "
148,148,"0 0.1751070798689846, 1 0.16099773242630383, 3 0.16099773242630383, 5 0.13101536911060718, 2 0.12925170068027209, 6 0.12925170068027209, 4 0.11337868480725624",place holder for https://github.com/apache/commons-lang/pull/309 fixes a bug where the increment count is not correctly propagated. 
149,149,"1 0.17794486215538846, 3 0.15065441381230854, 0 0.14285714285714285, 2 0.14285714285714285, 6 0.13311055416318576, 4 0.12726260094681152, 5 0.1253132832080201",reported in [https://github.com/apache/commons-lang/pull/307] 
150,150,"0 0.27062512247697434, 3 0.1512835586909661, 2 0.14579659024103467, 4 0.13756613756613756, 5 0.10190084264158336, 6 0.10190084264158336, 1 0.09092690574172058","in tostringstyle class, which checking if a string is a valid json array, the boolean check was wrong. original: {code:java} private boolean isjsonarray(final string valueasstring) { return valueasstring.startswith(getarraystart()) && valueasstring.startswith(getarrayend()); } {code} the second expression should be valueasstring.endswith(getarrayend()) "
151,151,"0 0.25874928284566845, 3 0.13558997896347294, 2 0.13157391470644483, 5 0.13157391470644483, 4 0.1302352266207688, 6 0.11417096959265634, 1 0.0981067125645439","the date format symbols of the french locale adds a . (dot) when short month names are really abbreviated. {code} janv. fÃ©vr. mars avr. mai juin juil. aoÃ»t sept. oct. nov. dÃ©c. {code} but in real world examples, the dot is frequently omitted. fastdateparser should be lenient in the case where the dot isnt there, e.g. ""14 avr 2014"". "
152,152,"0 0.24068322981366463, 4 0.15251897860593513, 1 0.14527260179434093, 2 0.13802622498274672, 3 0.13440303657694963, 6 0.11145617667356797, 5 0.07763975155279505",from the user mailing list [1]: jsontostringstyle does not escape double quote in a string value json requires double-quote to be escaped with a back-slash. this does not happen currently. nor does the code translate control characters such as nl and ff correctly. afaict the code is only guaranateed to process alphanumeric strings correctly. [1] https://lists.apache.org/thread.html/10bb632e86c473d58656431ad2702e058c58585e1a2edf1bf4a46824@%3cuser.commons.apache.org%3e 
153,153,"0 0.20362103174603172, 3 0.15848214285714285, 2 0.14285714285714282, 4 0.14285714285714282, 6 0.12723214285714282, 5 0.11334325396825398, 1 0.11160714285714288","json objects consist of a string : value pair. the string part can contain \""\ and \\\\ etc provided it is properly escaped. this is not currently supported."
154,154,"0 0.14285714285714285, 1 0.14285714285714285, 2 0.14285714285714285, 3 0.14285714285714285, 4 0.14285714285714285, 5 0.14285714285714285, 6 0.14285714285714285",
